var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  MapboxAddressAutofill: () => MapboxAddressAutofill,
  MapboxAddressConfirmation: () => MapboxAddressConfirmation,
  MapboxAddressMinimap: () => MapboxAddressMinimap,
  MapboxHTMLEvent: () => MapboxHTMLEvent,
  MapboxSearchBox: () => MapboxSearchBox,
  autofill: () => autofill,
  config: () => config,
  confirmAddress: () => confirmAddress,
  getAutofillSearchText: () => getAutofillSearchText,
  getFormAutofillValues: () => getFormAutofillValues
});

// src/utils/dom.ts
var subdoc = document.implementation.createHTMLDocument();
function bindElements(root, elements) {
  const binding = {};
  for (const [key, selector] of Object.entries(elements)) {
    binding[key] = root.querySelector(selector);
  }
  return binding;
}
function getChildElements(node) {
  return Array.from(node.childNodes || []).filter((el) => el.nodeType === Node.ELEMENT_NODE);
}
function createElementFromString(innerHTML) {
  const template = document.createElement("template");
  template.innerHTML = innerHTML;
  return template.content.firstElementChild;
}
function createCSSStyleSheet(text) {
  const style = subdoc.createElement("style");
  style.textContent = text;
  subdoc.head.appendChild(style);
  return style.sheet;
}
function isVisible(element) {
  const style = window.getComputedStyle(element);
  return style.display !== "none";
}
function setValue(input, value) {
  if (!input) {
    return;
  }
  const set = Object.getOwnPropertyDescriptor(input.constructor.prototype, "value").set;
  set.call(input, value);
  const wrapperState = input;
  if (wrapperState._valueTracker) {
    wrapperState._valueTracker.setValue("");
  }
  const onInputEvent = new Event("input", {
    bubbles: true
  });
  onInputEvent.simulated = true;
  input.dispatchEvent(onInputEvent);
  const onChangeEvent = new Event("change", {
    bubbles: true
  });
  onChangeEvent.simulated = true;
  input.dispatchEvent(onChangeEvent);
}
function getElementSize(element, deep = false) {
  let width;
  let height;
  const elementRect = element.getBoundingClientRect();
  if (element.style.display === "none" || elementRect.height === 0 && elementRect.width === 0) {
    const clone = element.cloneNode(deep);
    element.parentElement.appendChild(clone);
    clone.style.setProperty("display", "block", "important");
    const cloneRect = clone.getBoundingClientRect();
    width = cloneRect.width;
    height = cloneRect.height;
    clone.style.setProperty("display", "none");
    clone.remove();
  } else {
    width = elementRect.width;
    height = elementRect.height;
  }
  return {
    height: Math.floor(height),
    width: Math.floor(width)
  };
}
function addDocumentStyle(css) {
  const style = document.createElement("style");
  style.innerHTML = css;
  document.head.appendChild(style);
}

// src/utils/class_name_transformers.ts
var IDENTIFIER_REGEX = new RegExp("[_a-zA-Z]+[_a-zA-Z0-9-]*", "g");
var CLASS_NAME_REGEX = new RegExp(`\\.${IDENTIFIER_REGEX.source}`, "g");
var CONDITION_RULE_REGEX = new RegExp(`^\\s*(@(?:media|supports)[^{]*){(.*)}\\s*$`);
function transformClassSelectors(css, transform) {
  return css.replace(CLASS_NAME_REGEX, (className) => {
    return "." + transform(className.slice(1));
  });
}
function transformCSSClassRules(text, transform) {
  const sheet = createCSSStyleSheet(text);
  const rules = sheet.cssRules;
  function transformCSSRule(rule) {
    if (rule instanceof CSSStyleRule) {
      const selector = transformClassSelectors(rule.selectorText, transform);
      return `${selector} { ${rule.style.cssText} }`;
    }
    const atRule = CONDITION_RULE_REGEX.exec(rule.cssText.split("\n").join(""));
    if (atRule && atRule.length > 2) {
      const rule2 = atRule[1];
      const contents = atRule[2];
      return `${rule2} { ${transformCSSClassRules(contents, transform)} }`;
    }
    return rule.cssText;
  }
  let style = "";
  for (const rule of Array.from(rules)) {
    style += transformCSSRule(rule) + "\n\n";
  }
  return style.trim();
}
function transformDOMClassAttributes(content, transform) {
  const elements = Array.from(content.querySelectorAll("[class]"));
  elements.push(content);
  for (const element of elements) {
    const { classList } = element;
    for (const className of Array.from(classList)) {
      classList.remove(className);
      classList.add(transform(className));
    }
  }
  return content;
}

// src/utils/index.ts
var import_search_js_core = require("@mapbox/search-js-core");

// src/utils/map.ts
var FLY_TO_SPEED = 1.4;
function bboxViewport(map, bounds, delta = 0.5) {
  const { center, zoom } = map.cameraForBounds(bounds);
  const transformedZoom = Math.max(zoom - delta, 0);
  return {
    center,
    zoom: transformedZoom,
    speed: FLY_TO_SPEED
  };
}
function getMaxZoom(placeType) {
  switch (placeType) {
    case "street":
      return 15;
    case "neighborhood":
    case "postcode":
    case "locality":
    case "oaza":
      return 14;
    case "place":
    case "city":
      return 13;
    case "district":
      return 9;
    case "region":
    case "prefecture":
      return 6;
    case "country":
      return 4;
    default:
      return 16;
  }
}
function getStaticBaseUrl(username, styleId) {
  return `https://api.mapbox.com/styles/v1/${username}/${styleId}/static/`;
}

// src/icons/close.svg
var close_default = '<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.8 3.8a1 1 0 0 1 1.4 0L9 7.58l3.8-3.8a1 1 0 1 1 1.4 1.42L10.42 9l3.8 3.8a1 1 0 0 1-1.42 1.4L9 10.42l-3.8 3.8a1 1 0 0 1-1.4-1.42L7.58 9l-3.8-3.8a1 1 0 0 1 0-1.4Z" fill="currentColor"/></svg>';

// src/icons/loading.svg
var loading_default = '<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/></svg>';

// src/constants.ts
var STATIC_BASE_URL_SATELLITE = getStaticBaseUrl("mapbox", "satellite-streets-v11");
var AUTOFILL_SKU_TOKEN_PREFIX = "20d01";
var MAPBOX_DOMAINS = ["mapbox.com", "mapbox.cn", "tilestream.net"];
var LISTBOX_TEMPLATE = createElementFromString(`
<template>
  <div class="MapboxSearch">
    <div class="Label" role="label" aria-live="polite" aria-atomic="true">
    </div>
    <div class="Results" aria-hidden="true">
      <div class="ResultsList" role="listbox">
      </div>
      <div class="ResultsAttribution" aria-hidden="true">
        <a href="https://www.mapbox.com/search-service" target="_blank" tabindex="-1">
          Powered by Mapbox
        </a>
      </div>
    </div>
  </div>
</template>
`);
var LISTBOX_SUGGESTION_TEMPLATE = createElementFromString(`
<template>
  <div class="Suggestion" role="option" tabindex="-1">
    <div class="SuggestionIcon" aria-hidden="true"></div>
    <div class="SuggestionText">
      <div class="SuggestionName"></div>
      <div class="SuggestionDesc"></div>
    </div>
  </div>
</template>
`);
var SEARCHBOX_TEMPLATE = createElementFromString(`
<template>
  <div class="SearchBox">
    <div class="SearchIcon"></div>
    <input class="Input" type="text" />
    <div class="ActionIcon">
      <button aria-label="Clear" class="ClearBtn">${close_default}</button>
      <div class="LoadingIcon">${loading_default}</div>
    </div>
  </div>
</template>
`);

// src/utils/index.ts
function randomValidID() {
  return `mbx` + new import_search_js_core.SessionToken().id.slice(0, 8);
}
function tryParseJSON(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    return null;
  }
}
function deepEquals(a, b) {
  if (a == null || b == null) {
    return a === b;
  }
  if (typeof a !== "object" || typeof b !== "object") {
    return a === b;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  for (const key of aKeys) {
    if (!deepEquals(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function round(num, decimalPlaces) {
  const factorOfTen = Math.pow(10, decimalPlaces);
  return Math.round(num * factorOfTen) / factorOfTen;
}
function isLocalServer(hostname) {
  return Boolean(hostname.match(/localhost|[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}|::1|\.local|^$/gi));
}
function isMapboxDomain(hostname) {
  return Boolean(MAPBOX_DOMAINS.some((domain) => hostname.includes(domain)));
}

// src/components/HTMLScopedElement.ts
var _seed, _templateUserStyleElement, _transform;
var HTMLScopedElement = class extends HTMLElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _seed, randomValidID());
    __privateAdd(this, _templateUserStyleElement, void 0);
    __privateAdd(this, _transform, (className) => {
      return `${__privateGet(this, _seed)}--${className}`;
    });
  }
  get template() {
    return null;
  }
  get templateStyle() {
    return null;
  }
  get templateUserStyle() {
    return null;
  }
  clonedCallback(oldSeed, newSeed) {
    const seedTransform = (className) => className.replace(oldSeed, newSeed);
    transformDOMClassAttributes(this, seedTransform);
    const styles = Array.from(this.querySelectorAll("style"));
    for (const style of styles) {
      style.textContent = transformClassSelectors(style.textContent, seedTransform);
    }
    if (styles.length) {
      __privateSet(this, _templateUserStyleElement, styles[styles.length - 1]);
    }
    const nodesWithId = Array.from(this.querySelectorAll(`[id^="${oldSeed}"]`));
    for (const node of nodesWithId) {
      node.id = node.id.replace(oldSeed, newSeed);
    }
  }
  connectedCallback() {
    if (this.childElementCount > 0) {
      const oldSeed = this.dataset.seed;
      const newSeed = __privateGet(this, _seed);
      if (oldSeed && oldSeed !== newSeed) {
        this.clonedCallback(oldSeed, newSeed);
        this.dataset.seed = newSeed;
      }
      return;
    }
    this.dataset.seed = __privateGet(this, _seed);
    const template = this.template;
    if (template) {
      const element = this.prepareTemplate(template);
      this.appendChild(element);
    }
    const templateStyle = this.templateStyle;
    if (templateStyle) {
      const style = document.createElement("style");
      style.textContent = this.prepareCSS(templateStyle);
      this.appendChild(style);
    }
    const userStyle = document.createElement("style");
    if (this.templateUserStyle) {
      userStyle.textContent = this.prepareCSS(this.templateUserStyle);
    }
    this.appendChild(userStyle);
    __privateSet(this, _templateUserStyleElement, userStyle);
  }
  prepareTemplate(template) {
    const element = template.content.firstElementChild;
    return transformDOMClassAttributes(element.cloneNode(true), __privateGet(this, _transform));
  }
  prepareCSS(css) {
    return transformCSSClassRules(css, __privateGet(this, _transform));
  }
  updateTemplateUserStyle(style) {
    if (!__privateGet(this, _templateUserStyleElement)) {
      return;
    }
    __privateGet(this, _templateUserStyleElement).textContent = this.prepareCSS(style);
  }
  querySelector(selectors) {
    return super.querySelector(transformClassSelectors(selectors, __privateGet(this, _transform)));
  }
  querySelectorAll(selectors) {
    return super.querySelectorAll(transformClassSelectors(selectors, __privateGet(this, _transform)));
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return super.dispatchEvent(event);
  }
};
_seed = new WeakMap();
_templateUserStyleElement = new WeakMap();
_transform = new WeakMap();

// src/icons/question.svg
var question_default = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 16A7 7 0 1 0 9 2a7 7 0 0 0 0 14ZM6.88 4.88a2.58 2.58 0 0 1 1.83-.75h1.08a2.58 2.58 0 0 1 2.59 2.58v.16c0 1-.53 1.94-1.4 2.46l-.56.34c-.27.16-.45.42-.52.71-.03.14-.14.25-.28.25H8.38a.23.23 0 0 1-.24-.25c.08-.91.59-1.74 1.38-2.21l.56-.34c.34-.2.54-.57.54-.96V6.7a.83.83 0 0 0-.83-.83H8.71a.83.83 0 0 0-.84.83v.18a.87.87 0 1 1-1.75 0V6.7c0-.69.28-1.34.76-1.83ZM10 13a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z" fill="currentColor"/></svg>';

// src/icons/marker.svg
var marker_default = '<svg width="48" height="56" fill="none" xmlns="http://www.w3.org/2000/svg"><g filter="url(#a)"><path d="m24 50.4 13.79-14.12a18.82 18.82 0 0 0 4.23-20.86 19.23 19.23 0 0 0-7.19-8.6 19.76 19.76 0 0 0-21.66 0c-3.21 2.11-5.71 5.1-7.19 8.6a18.82 18.82 0 0 0 4.23 20.86L24 50.4Z" fill="currentColor"/><path d="M37.26 35.75 24 49.34 10.75 35.76l-.01-.01A18.07 18.07 0 0 1 6.68 15.7a18.48 18.48 0 0 1 6.9-8.26 19 19 0 0 1 20.84 0 18.48 18.48 0 0 1 6.9 8.26 18.07 18.07 0 0 1-4.06 20.04Z" stroke="#fff" stroke-width="1.5"/></g><circle cx="24" cy="22.45" fill="#fff" r="5.85"/><defs><filter id="a" x=".5" y=".6" width="47" height="54.8" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feColorMatrix in="SourceAlpha" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/><feOffset dy="1"/><feGaussianBlur stdDeviation="2"/><feColorMatrix values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0"/><feBlend in2="BackgroundImageFix" result="effect1_dropShadow_17_871"/><feBlend in="SourceGraphic" in2="effect1_dropShadow_17_871" result="shape"/></filter></defs></svg>';

// src/icons/street.svg
var street_default = '<svg width="24" height="24" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">\n  <path fill-rule="evenodd" clip-rule="evenodd" d="M1.08 14.94 5.625 3.06h1.17l-3.42 11.88H1.08Zm15.885 0L12.42 3.06h-1.17l3.42 11.88h2.295Zm-6.86-1.44H7.946l.128-2.61h1.912l.119 2.61Zm-.217-4.77H8.181l.088-1.8h1.537l.082 1.8ZM9.74 5.49h-1.4l.049-.99h1.306l.045.99Z" fill="currentColor" />\n</svg>';

// src/icons/addressMarker.svg
var addressMarker_default = `<!-- TODO: I'm not sure if the way I added the circle will "scale" properly, need to check that -->
<svg width="24" height="24" viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">
  <path fill="none" stroke="currentColor" stroke-width="1.5" d="M4 7a5 5 0 1 1 10 0c0 3.025-3.28 6.713-5 9-1.72-2.287-5-5.975-5-9z"></path>
    <circle cx="9" cy="7" r="2" fill="currentColor"></circle>
</svg>`;

// src/icons/search.svg
var search_default = '<svg viewBox="0 0 18 18" xmlns="http://www.w3.org/2000/svg">\n  <path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>\n</svg>';

// package.json
var version = "1.0.0-beta.19";

// src/theme.ts
var styleToggleSatelliteImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-satellite.jpg`;
var styleToggleDefaultImg = `https://api.mapbox.com/search-js/v${version}/img/style-toggle-default.jpg`;
var MOBILE_BREAKPOINT = 768 - 1;
var MOBILE_MEDIA_QUERY = `@media only screen and (max-width: ${MOBILE_BREAKPOINT}px)`;
var DEFAULT_THEME = {
  variables: {
    unit: ["mobile", "16px", "14px"],
    unitHeader: ["mobile", "24px", "18px"],
    minWidth: "min(300px, 100vw)",
    spacing: "0.75em",
    padding: "0.5em 0.75em",
    paddingFooterLabel: "0.5em 0.75em",
    paddingModal: "1.25em",
    colorText: "rgba(0, 0, 0, 0.75)",
    colorPrimary: "#4264FB",
    colorSecondary: "#667F91",
    colorBackground: "#fff",
    colorBackgroundHover: "#f5f5f5",
    colorBackgroundActive: "#f0f0f0",
    colorBackdrop: "rgba(102, 127, 145, 0.3)",
    border: "none",
    borderRadius: "4px",
    boxShadow: `
      0 0 10px 2px rgba(0, 0, 0, 0.05),
      0 0 6px 1px rgba(0, 0, 0, 0.1),
      0 0 0 1px rgba(0, 0, 0, 0.1)
    `,
    lineHeight: "1.2em",
    fontFamily: `
      -apple-system, BlinkMacSystemFont,
      avenir next, avenir,
      segoe ui,
      helvetica neue, helvetica,
      Ubuntu, roboto, noto, arial, sans-serif
    `,
    fontWeight: "normal",
    fontWeightSemibold: "600",
    fontWeightBold: "bold",
    duration: "150ms",
    curve: "ease-out"
  },
  icons: {
    close: close_default,
    question: question_default,
    marker: marker_default,
    street: street_default,
    addressMarker: addressMarker_default,
    search: search_default
  },
  images: {
    styleToggleDefault: styleToggleDefaultImg,
    styleToggleSatellite: styleToggleSatelliteImg
  }
};
function getThemeCSS(rootSelector, theme = {}) {
  const variables = __spreadValues(__spreadValues({}, DEFAULT_THEME.variables), theme.variables || {});
  let cssText = theme.cssText || "";
  let rootVariables = "";
  for (const [key, value] of Object.entries(variables)) {
    if (!Array.isArray(value)) {
      rootVariables += `--${key}: ${value};`;
      continue;
    }
    if (value[0] !== "mobile") {
      const valueStr = JSON.stringify(value);
      throw new Error(`Unsupported expression in theme variables: ${key} ${valueStr}`);
    }
    const [, mobileValue, desktopValue] = value;
    cssText += `${MOBILE_MEDIA_QUERY} { ${rootSelector} { --${key}: ${mobileValue} !important; } }`;
    rootVariables += `--${key}: ${desktopValue};`;
  }
  return cssText + `${rootSelector} { ${rootVariables} }`;
}
function getIcon(iconName, theme = {}) {
  const icons = __spreadValues(__spreadValues({}, DEFAULT_THEME.icons), theme.icons || {});
  const svgString = icons[iconName];
  return svgString;
}
function getImage(imageName, theme = {}) {
  const images = __spreadValues(__spreadValues({}, DEFAULT_THEME.images), theme.images || {});
  const imgString = images[imageName];
  return imgString;
}

// src/utils/popover.ts
var import_dom3 = require("@floating-ui/dom");
var _options, _defaultOptions;
var Popover = class {
  constructor(referenceEl, floatingEl, options) {
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _defaultOptions, {
      placement: "bottom-start",
      flip: false,
      offset: 10
    });
    this.update = () => __async(this, null, function* () {
      const config2 = {
        placement: this.options.placement,
        middleware: [
          (0, import_dom3.offset)(this.options.offset),
          this.options.flip && (0, import_dom3.flip)()
        ].filter(Boolean)
      };
      const { x, y } = yield (0, import_dom3.computePosition)(this.referenceEl, this.floatingEl, config2);
      Object.assign(this.floatingEl.style, {
        left: `${x}px`,
        top: `${y}px`
      });
    });
    this.referenceEl = referenceEl;
    this.floatingEl = floatingEl;
    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _defaultOptions)), options));
    this.destroy = (0, import_dom3.autoUpdate)(this.referenceEl, this.floatingEl, this.update);
  }
  get options() {
    return __privateGet(this, _options);
  }
  set options(newOptions) {
    __privateSet(this, _options, __spreadValues(__spreadValues({}, __privateGet(this, _options)), newOptions));
  }
};
_options = new WeakMap();
_defaultOptions = new WeakMap();

// src/style.css
var style_default = "*{box-sizing:border-box!important}[role=button]{cursor:pointer}.MapboxSearch{--width:0;display:none}.Results{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);min-width:var(--minWidth);overflow-y:auto;position:absolute;transform:translateZ(0);transition:visibility var(--duration);width:var(--width);z-index:1000}.Results:not([aria-hidden=true]){visibility:visible}.Results[aria-hidden=true]{animation:fadein var(--duration) var(--curve) reverse forwards;visibility:hidden}.Suggestion{align-items:center;display:flex;padding:var(--padding)}.Suggestion:hover{cursor:pointer}.Suggestion[aria-selected=true]{background-color:var(--colorBackgroundHover)}.Suggestion:active{background-color:var(--colorBackgroundActive)}.SuggestionName{font-weight:var(--fontWeightBold)}.SuggestionIcon{margin-right:6px}.SuggestionIcon[aria-hidden=true]{display:none}.ResultsAttribution{padding:var(--paddingFooterLabel)}.ResultsAttribution a{color:var(--colorSecondary)}.ResultsAttribution a:not(:hover){text-decoration:none}.ResultsList{list-style:none;margin:0;padding:0}.Label{display:none}.SearchBox{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--padding);padding-bottom:0;padding-top:0;position:relative;width:100%}.SearchIcon{fill:#757575;left:.5em}.ActionIcon,.SearchIcon{bottom:0;height:20px;margin:auto 0;position:absolute;top:0;width:20px}.ActionIcon{right:.5em}.ActionIcon>button{background:none;border:none;color:inherit;cursor:pointer;font:inherit;height:100%;outline:inherit;padding:0;width:100%}.ActionIcon>button:hover{background:none!important}.ClearBtn{display:none}.ClearBtn:hover{color:#909090}.LoadingIcon{-moz-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;-webkit-animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;animation:rotate .8s cubic-bezier(.45,.05,.55,.95) infinite;display:none;height:100%}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.Input{background-color:transparent;border:0;color:#404040;color:rgba(0,0,0,.75);font:inherit;height:36px;margin:0;overflow:hidden;padding:0 40px;text-overflow:ellipsis;white-space:nowrap;width:100%}.Input::-ms-clear{display:none}.Input:focus{border:thin dotted;border-radius:var(--borderRadius);box-shadow:none;color:#404040;color:rgba(0,0,0,.75);outline:0}mapbox-address-confirmation-feature[aria-hidden=true],mapbox-address-confirmation-no-feature[aria-hidden=true]{display:none}.MapboxAddressConfirmation{align-items:center;background-color:var(--colorBackdrop);bottom:0;display:flex;justify-content:center;left:0;position:fixed;right:0;top:0;transform:translateZ(0);z-index:1000}.MapboxAddressConfirmation:not([aria-hidden=true]){animation:fadein var(--duration) var(--curve) forwards;visibility:visible}.MapboxAddressConfirmation[aria-hidden=true]{visibility:hidden}.ContentFeature,.ContentNoFeature{width:var(--minWidth)}.Modal{background-color:var(--colorBackground);border:var(--border);border-radius:var(--borderRadius);box-shadow:var(--boxShadow);color:var(--colorText);font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight);padding:var(--paddingModal);width:100%}@media screen and (max-width:480px){.MapboxAddressConfirmation{align-items:flex-end}.ContentFeature,.ContentNoFeature{width:100%}.Modal{border-bottom-left-radius:0;border-bottom-right-radius:0}}.ModalHeader{align-items:center;color:var(--colorPrimary);display:flex;font-size:var(--unitHeader);font-weight:var(--fontWeightBold);margin-bottom:var(--spacing);user-select:none;width:100%}.ModalMap{height:calc(var(--minWidth)*9/16);margin-left:calc(var(--paddingModal)*-1);width:calc(100% + var(--paddingModal)*2)}.ModalMap[aria-hidden=true]{display:none}.Icon{height:var(--unitHeader);width:var(--unitHeader)}.Icon.IconClose{color:var(--colorSecondary)}.ModalHeaderTitle{flex:1;margin-left:.25em}.ModalFooter{color:var(--colorSecondary);margin-top:var(--spacing);text-align:center}.ModalFooter[aria-hidden=true]{display:none}.ModalSubheader{font-weight:var(--fontWeightBold);user-select:none}.ModalDescription{color:var(--colorPrimary)}.ModalAddress,.ModalSubheader{margin-bottom:var(--spacing)}.ModalAddress.ModalAddressApprove{color:var(--colorPrimary)}.Button{border-radius:var(--borderRadius);cursor:pointer;font-weight:var(--fontWeightSemibold);margin-top:var(--spacing);padding:var(--padding);text-align:center;user-select:none;width:100%}.Button[aria-hidden=true]{display:none}.Button.ButtonPrimary{background-color:var(--colorPrimary);color:var(--colorBackground)}.Button.ButtonSecondary{border:1px solid var(--colorSecondary);color:var(--colorSecondary)}@keyframes fadein{0%{opacity:0}to{opacity:1}}.MapboxAddressMinimap{font-family:var(--fontFamily);font-size:var(--unit);font-weight:var(--fontWeight);line-height:var(--lineHeight)}.MapboxAddressMinimap[aria-hidden=true]{display:none}.MinimapImageContainer{border-radius:var(--borderRadius);overflow:hidden}.MinimapImage{height:unset;max-height:unset;max-width:unset;position:relative;width:unset}.MinimapInnerFrame{border:var(--border);border-radius:inherit;height:inherit;left:0;overflow:hidden;position:absolute;top:0;width:inherit}.MinimapMarker{left:50%;position:absolute;top:50%}.MinimapMarker>svg{color:var(--colorPrimary);display:block!important}.MinimapAttributionLogo{bottom:0;left:0;margin:0 0 6px 6px;position:absolute}.MinimapAttributionLogo a{cursor:pointer;display:block;height:23px;width:88px}.MinimapAttributionText{background-color:hsla(0,0%,100%,.65);bottom:0;font:11px/16px Helvetica Neue,Arial,Helvetica,sans-serif;padding:0 5px;position:absolute;right:0}.MinimapAttributionText a{color:rgba(0,0,0,.75);text-decoration:none}.MinimapAttributionText a:hover{color:inherit;text-decoration:underline}.MinimapAttributionText a:not(:first-child){margin-left:3px}.MinimapStyleToggle{background-position:0;background-repeat:no-repeat;background-size:contain;border:2px solid #fff;border-radius:3px;box-shadow:var(--boxShadow);cursor:pointer;height:2em;position:absolute;right:var(--spacing);top:var(--spacing);width:2em}.MinimapFooter{color:var(--colorSecondary);font-family:var(--fontFamily);font-size:var(--unit);margin-top:var(--spacing)}.MinimapFooter[aria-hidden=true]{display:none}.MinimapEditButtons{bottom:26px;display:flex;font-family:var(--fontFamily);position:absolute;right:var(--spacing)}.MinimapEditButtons .Button{box-shadow:var(--boxShadow)}.MinimapButtonCancel{background-color:var(--colorBackground);margin-left:var(--spacing)}.draggable{cursor:move;cursor:grab}.draggable:active{cursor:grabbing}";

// src/MapboxHTMLEvent.ts
var MapboxHTMLEvent = class extends CustomEvent {
  constructor(type, detail) {
    super(type, {
      composed: true,
      detail
    });
  }
  clone(newTarget) {
    const eventClone = new MapboxHTMLEvent(this.type, this.detail);
    if (newTarget) {
      Object.defineProperty(eventClone, "target", { value: newTarget });
    }
    return eventClone;
  }
};

// src/utils/aria/messages.ts
var LENGTH_MESSAGE = "Type in 2 or more characters for results.";
var KEYBOARD_NAVIGATION_GUIDE_MESSAGE = "When autocomplete results are available use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.";
var NO_SEARCH_RESULTS_MESSAGE = "No search results.";
var getSuggestionSelectedMessage = (address, numberOfResults, currentIndex) => `${numberOfResults} ${numberOfResults === 1 ? "result is" : "results are"} available. ${address}. ${currentIndex} of ${numberOfResults} is selected.`;
var getSuggestionsReadyMessage = (numberOfResults) => `${numberOfResults} ${numberOfResults === 1 ? "result is" : "results are"} available. Use up and down arrows to review and enter to select. Touch device users, explore by touch or with swipe gestures.`;

// src/utils/aria/index.ts
function ariaButtonKeyDown(e) {
  const el = e.currentTarget;
  if (e.key === " " || e.key === "Enter") {
    e.preventDefault();
    e.stopPropagation();
    el.dispatchEvent(new MouseEvent("click", {
      bubbles: true,
      composed: true
    }));
  }
}
var ARIA_DESCRIPTION_ID = "search-listbox__description";
var createAriaLiveElement = (seed) => {
  const container = document.createElement("div");
  container.setAttribute("aria-live", "polite");
  container.setAttribute("aria-atomic", "true");
  container.setAttribute("role", "status");
  container.setAttribute("style", "border: 0px;clip: rect(0px, 0px, 0px, 0px);height: 1px;margin-bottom: -1px;margin-right: -1px;overflow: hidden;padding: 0px;position: absolute;white-space: nowrap;width: 1px;");
  const description = document.createElement("div");
  description.setAttribute("id", `${seed}--${ARIA_DESCRIPTION_ID}`);
  container.appendChild(description);
  return container;
};
var setLiveRegionMessage = (message, seed) => {
  var _a;
  const description = (_a = document.body.querySelector(`[id="${seed}--${ARIA_DESCRIPTION_ID}"]`)) != null ? _a : null;
  if (description) {
    description.textContent = message;
  }
};
var suppressExtensionsAutocomplete = (input) => {
  input.name = input.name + " address-search";
  input.setAttribute("data-lpignore", "true");
};
var getAriaMessage = (searchValue, suggestions, selectedIndex) => {
  let ariaMessage = null;
  const noResults = !suggestions || suggestions.length === 0;
  if ((searchValue == null ? void 0 : searchValue.length) < 2) {
    ariaMessage = LENGTH_MESSAGE + " " + KEYBOARD_NAVIGATION_GUIDE_MESSAGE;
  } else if (noResults) {
    ariaMessage = NO_SEARCH_RESULTS_MESSAGE;
  } else if (selectedIndex !== void 0) {
    const suggestion = suggestions[selectedIndex];
    const placeName = suggestion.address || suggestion.full_address || suggestion.feature_name;
    ariaMessage = getSuggestionSelectedMessage(placeName, suggestions.length, selectedIndex + 1);
  } else {
    ariaMessage = getSuggestionsReadyMessage(suggestions.length);
  }
  return ariaMessage;
};

// src/utils/listbox.ts
var getSuggestionTitle = (item, service) => {
  switch (service) {
    case 0 /* AddressAutofill */:
      return item.address_line1 || item.matching_name || item.feature_name;
    case 3 /* SearchBox */:
      return item.name;
    case 1 /* GeocodingV5 */:
      return item.place_name.split(",")[0];
    default:
      return "";
  }
};
var buildSuggestionDescription = (item, service) => {
  switch (service) {
    case 0 /* AddressAutofill */:
      return item.description;
    case 3 /* SearchBox */:
      if (item.feature_type === "poi") {
        return item.full_address;
      }
      return item.place_formatted;
    case 1 /* GeocodingV5 */:
      return item.place_name.split(",").splice(1).join(",").trim();
    default:
      return "";
  }
};

// src/components/MapboxSearchListbox.ts
function getAriaIdForSuggestion(resultListId, i) {
  return `${resultListId}-${i}`;
}
var _popover, _binding, _labelID, _resultListID, _inputInternal, _searchService, _selectedIndexInternal, _showResults, showResults_fn, _renderResultsList, renderResultsList_fn, _themeInternal, _popoverOptions, _handleInput, _handleSelect, _handleFocus, _handleBlur, _handleKeyDown;
var MapboxSearchListbox = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _showResults);
    __privateAdd(this, _renderResultsList);
    this.suggestions = null;
    __privateAdd(this, _popover, null);
    __privateAdd(this, _binding, void 0);
    __privateAdd(this, _labelID, void 0);
    __privateAdd(this, _resultListID, void 0);
    __privateAdd(this, _inputInternal, void 0);
    __privateAdd(this, _searchService, null);
    __privateAdd(this, _selectedIndexInternal, void 0);
    __privateAdd(this, _themeInternal, {});
    __privateAdd(this, _popoverOptions, {});
    __privateAdd(this, _handleInput, (e) => {
      const { Results } = __privateGet(this, _binding);
      const input = e.target;
      if (input.dataset["mapboxSuccess"]) {
        delete input.dataset["mapboxSuccess"];
        return;
      }
      const searchText = input.value;
      this.renderAriaMessage();
      Results.setAttribute("aria-busy", "true");
      this.dispatchEvent(new MapboxHTMLEvent("input", searchText));
    });
    this.renderAriaMessage = () => {
      var _a;
      const message = getAriaMessage((_a = this.input) == null ? void 0 : _a.value, this.suggestions, this.selectedIndex);
      setLiveRegionMessage(message, this.dataset.seed);
    };
    this.clearAriaMessage = () => {
      setLiveRegionMessage("", this.dataset.seed);
    };
    this.handleSuggest = (suggestions) => {
      this.suggestions = suggestions;
      if (!suggestions || suggestions.length === 0) {
        this.renderAriaMessage();
      }
      if (!suggestions) {
        this.hideResults();
        return;
      }
      __privateMethod(this, _renderResultsList, renderResultsList_fn).call(this);
      if (suggestions.length) {
        __privateMethod(this, _showResults, showResults_fn).call(this);
      }
      const { Results } = __privateGet(this, _binding);
      Results.setAttribute("aria-busy", "false");
    };
    this.handleError = () => {
      const { Results } = __privateGet(this, _binding);
      Results.setAttribute("aria-busy", "false");
      this.hideResults();
    };
    __privateAdd(this, _handleSelect, (suggestion) => __async(this, null, function* () {
      const input = this.input;
      if (input) {
        input.dataset["mapboxSuccess"] = "true";
      }
      this.dispatchEvent(new MapboxHTMLEvent("select", suggestion));
      this.hideResults();
    }));
    __privateAdd(this, _handleFocus, () => {
      const input = this.input;
      delete input.dataset["mapboxSuccess"];
      this.dispatchEvent(new MapboxHTMLEvent("focus"));
      this.renderAriaMessage();
      __privateMethod(this, _showResults, showResults_fn).call(this);
    });
    __privateAdd(this, _handleBlur, () => {
      if (document.activeElement === this.input) {
        return;
      }
      this.dispatchEvent(new MapboxHTMLEvent("blur"));
      this.clearAriaMessage();
      this.hideResults();
    });
    this.handleArrowUp = () => {
      if (this.selectedIndex === void 0) {
        this.selectedIndex = this.suggestions.length - 1;
      } else if (this.selectedIndex === 0) {
        this.selectedIndex = void 0;
      } else {
        this.selectedIndex = Math.max(0, this.selectedIndex - 1);
      }
    };
    this.handleArrowDown = () => {
      if (this.selectedIndex === void 0) {
        this.selectedIndex = 0;
      } else if (this.selectedIndex === this.suggestions.length - 1) {
        this.selectedIndex = void 0;
      } else {
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.suggestions.length - 1);
      }
    };
    __privateAdd(this, _handleKeyDown, (e) => {
      var _a;
      if (!((_a = this.suggestions) == null ? void 0 : _a.length))
        return;
      if (e.key === "ArrowDown") {
        e.preventDefault();
        this.handleArrowDown();
        return;
      }
      if (e.key === "ArrowUp") {
        e.preventDefault();
        this.handleArrowUp();
        return;
      }
      if (e.key === "Escape") {
        this.hideResults();
        return;
      }
      if (this.selectedIndex === void 0) {
        return;
      }
      if (e.key === "Tab") {
        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);
        return;
      }
      if (e.key === "Enter") {
        e.preventDefault();
        __privateGet(this, _handleSelect).call(this, this.suggestions[this.selectedIndex]);
        return;
      }
    });
  }
  get template() {
    return LISTBOX_TEMPLATE;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxSearch", this.theme);
  }
  get input() {
    return __privateGet(this, _inputInternal);
  }
  set input(newInput) {
    const oldInput = __privateGet(this, _inputInternal);
    if (oldInput) {
      oldInput.removeEventListener("input", __privateGet(this, _handleInput));
      oldInput.removeEventListener("focus", __privateGet(this, _handleFocus));
      oldInput.removeEventListener("blur", __privateGet(this, _handleBlur));
      oldInput.removeEventListener("keydown", __privateGet(this, _handleKeyDown));
      if (__privateGet(this, _popover)) {
        __privateGet(this, _popover).destroy();
      }
    }
    if (newInput) {
      newInput.addEventListener("input", __privateGet(this, _handleInput));
      newInput.addEventListener("focus", __privateGet(this, _handleFocus));
      newInput.addEventListener("blur", __privateGet(this, _handleBlur));
      newInput.addEventListener("keydown", __privateGet(this, _handleKeyDown));
      newInput.setAttribute("role", "combobox");
      newInput.setAttribute("aria-autocomplete", "list");
      newInput.setAttribute("aria-controls", __privateGet(this, _resultListID));
      if (this.isConnected) {
        __privateSet(this, _popover, new Popover(newInput, __privateGet(this, _binding).Results, this.popoverOptions));
      }
    }
    __privateSet(this, _inputInternal, newInput);
  }
  get searchService() {
    return __privateGet(this, _searchService);
  }
  set searchService(service) {
    __privateSet(this, _searchService, service);
  }
  get selectedIndex() {
    return __privateGet(this, _selectedIndexInternal);
  }
  set selectedIndex(newIndex) {
    const oldIndex = __privateGet(this, _selectedIndexInternal);
    __privateSet(this, _selectedIndexInternal, newIndex);
    const { ResultsList } = __privateGet(this, _binding);
    const id = getAriaIdForSuggestion(__privateGet(this, _resultListID), newIndex);
    if (newIndex !== void 0) {
      this.input.setAttribute("aria-activedescendant", id);
      ResultsList.setAttribute("aria-activedescendant", id);
    } else {
      this.input.removeAttribute("aria-activedescendant");
      ResultsList.removeAttribute("aria-activedescendant");
    }
    if (oldIndex !== newIndex) {
      const oldId = getAriaIdForSuggestion(__privateGet(this, _resultListID), oldIndex);
      const oldEl = ResultsList.querySelector(`#${oldId}`);
      oldEl == null ? void 0 : oldEl.removeAttribute("aria-selected");
      oldEl == null ? void 0 : oldEl.setAttribute("tabindex", "-1");
      if (newIndex !== void 0) {
        const el = ResultsList.querySelector(`#${id}`);
        el == null ? void 0 : el.setAttribute("aria-selected", "true");
        el == null ? void 0 : el.setAttribute("tabindex", "0");
      }
    }
    this.renderAriaMessage();
  }
  hideResults() {
    const { Results, ResultsList } = __privateGet(this, _binding);
    Results.setAttribute("aria-hidden", "true");
    this.input.setAttribute("aria-expanded", "false");
    ResultsList.removeAttribute("aria-activedescendant");
    this.input.removeAttribute("aria-activedescendant");
  }
  renderItem(i) {
    const element = this.prepareTemplate(LISTBOX_SUGGESTION_TEMPLATE);
    element.id = getAriaIdForSuggestion(__privateGet(this, _resultListID), i);
    return element;
  }
  fillItem(el, item, i, totalLength) {
    const iconEl = el.querySelector('[class$="SuggestionIcon"]');
    const nameEl = el.querySelector('[class$="SuggestionName"]');
    const descriptionEl = el.querySelector('[class$="SuggestionDesc"]');
    if (this.searchService === 0 /* AddressAutofill */) {
      iconEl.innerHTML = getIcon(item.accuracy === "street" ? "street" : "addressMarker", this.theme);
      iconEl.removeAttribute("aria-hidden");
    } else {
      iconEl.setAttribute("aria-hidden", "true");
    }
    nameEl.textContent = descriptionEl.textContent = "";
    nameEl.textContent = getSuggestionTitle(item, this.searchService);
    descriptionEl.textContent = buildSuggestionDescription(item, this.searchService);
    if (i === this.selectedIndex) {
      el.setAttribute("aria-selected", "true");
    } else {
      el.removeAttribute("aria-selected");
    }
    el.setAttribute("aria-posinset", (i + 1).toString());
    el.setAttribute("aria-setsize", totalLength.toString());
  }
  get theme() {
    return __privateGet(this, _themeInternal);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal, theme);
    if (!__privateGet(this, _binding) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxSearch", theme));
  }
  get popoverOptions() {
    return __privateGet(this, _popoverOptions);
  }
  set popoverOptions(newOptions) {
    __privateSet(this, _popoverOptions, newOptions);
    if (__privateGet(this, _popover)) {
      __privateGet(this, _popover).options = newOptions;
      __privateGet(this, _popover).update();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    this.dataSeed = this.dataset.seed;
    __privateSet(this, _labelID, this.dataset.seed + "-Label");
    __privateSet(this, _resultListID, this.dataset.seed + "-ResultsList");
    if (this.input) {
      this.input.setAttribute("aria-controls", __privateGet(this, _resultListID));
    }
    __privateSet(this, _binding, bindElements(this, {
      MapboxSearch: ".MapboxSearch",
      Results: ".Results",
      ResultsList: ".ResultsList",
      Label: ".Label"
    }));
    const { Results, ResultsList, Label } = __privateGet(this, _binding);
    Label.id = __privateGet(this, _labelID);
    ResultsList.id = __privateGet(this, _resultListID);
    ResultsList.setAttribute("aria-labelledby", __privateGet(this, _labelID));
    Results.addEventListener("blur", __privateGet(this, _handleBlur));
    if (!__privateGet(this, _popover) && this.input) {
      __privateSet(this, _popover, new Popover(this.input, __privateGet(this, _binding).Results, this.popoverOptions));
    }
    requestAnimationFrame(() => {
      if (__privateGet(this, _popover)) {
        __privateGet(this, _popover).update();
      }
    });
  }
  disconnectedCallback() {
    this.input = null;
    const { Results } = __privateGet(this, _binding);
    Results.removeEventListener("blur", __privateGet(this, _handleBlur));
    if (__privateGet(this, _popover))
      __privateGet(this, _popover).destroy();
  }
  focus() {
    if (document.activeElement === this.input) {
      __privateGet(this, _handleFocus).call(this);
    } else {
      this.input.focus();
    }
  }
  blur() {
    this.input.blur();
  }
  updatePopover() {
    if (__privateGet(this, _popover)) {
      __privateGet(this, _popover).update();
    }
  }
};
_popover = new WeakMap();
_binding = new WeakMap();
_labelID = new WeakMap();
_resultListID = new WeakMap();
_inputInternal = new WeakMap();
_searchService = new WeakMap();
_selectedIndexInternal = new WeakMap();
_showResults = new WeakSet();
showResults_fn = function() {
  if (!this.suggestions || !this.suggestions.length) {
    return;
  }
  const { Results, MapboxSearch } = __privateGet(this, _binding);
  const rect = this.input.getBoundingClientRect();
  MapboxSearch.style.setProperty("--width", `${rect.width}px`);
  MapboxSearch.style.setProperty("display", "block");
  this.input.setAttribute("aria-expanded", "true");
  Results.removeAttribute("aria-hidden");
  this.selectedIndex = void 0;
};
_renderResultsList = new WeakSet();
renderResultsList_fn = function() {
  const { ResultsList } = __privateGet(this, _binding);
  if (!this.suggestions || !this.suggestions.length) {
    ResultsList.innerHTML = "";
    this.hideResults();
    return;
  }
  const elements = getChildElements(ResultsList);
  if (this.suggestions.length > elements.length) {
    for (let i = elements.length; i < this.suggestions.length; i++) {
      const item = this.renderItem(i);
      elements.push(item);
      item.onmouseenter = () => {
        this.selectedIndex = i;
      };
      item.onmouseleave = () => {
        this.selectedIndex = void 0;
      };
      ResultsList.appendChild(item);
    }
  }
  if (this.suggestions.length < elements.length) {
    for (let i = this.suggestions.length; i < elements.length; i++) {
      elements[i].remove();
    }
  }
  for (const suggestion of this.suggestions) {
    const i = this.suggestions.indexOf(suggestion);
    const element = elements[i];
    this.fillItem(element, suggestion, i, this.suggestions.length);
    element.onclick = () => {
      __privateGet(this, _handleSelect).call(this, suggestion);
    };
  }
};
_themeInternal = new WeakMap();
_popoverOptions = new WeakMap();
_handleInput = new WeakMap();
_handleSelect = new WeakMap();
_handleFocus = new WeakMap();
_handleBlur = new WeakMap();
_handleKeyDown = new WeakMap();
window.MapboxSearchListbox = MapboxSearchListbox;
if (!window.customElements.get("mapbox-search-listbox")) {
  customElements.define("mapbox-search-listbox", MapboxSearchListbox);
}

// src/utils/autofill.ts
var import_search_js_core2 = require("@mapbox/search-js-core");
var AUTOFILL_TOKENS = /* @__PURE__ */ new Set([
  "street-address",
  "address-line1",
  "address-line2",
  "address-line3",
  "address-level4",
  "address-level3",
  "address-level2",
  "address-level1",
  "country",
  "country-name",
  "postal-code"
]);
var AUTOFILL_SKIP_TOKENS = /* @__PURE__ */ new Set(["off", "on", "true", "false"]);
function findParentForm(el) {
  let node = el.parentNode;
  while (node) {
    if (node instanceof HTMLFormElement) {
      return node;
    }
    node = node.parentNode;
  }
  return null;
}
function findAddressInputs(form) {
  const parent = form || document;
  return Array.from(parent.querySelectorAll('input[autocomplete~="address-line1"], input[autocomplete~="street-address"]'));
}
var SECTION = "section-";
var SECTION_DEFAULT = "section-default";
var SECTION_SHIPPING = "section-shipping";
var SECTION_BILLING = "section-billing";
function parseFormStructure(form) {
  const inputs = Array.from(form.querySelectorAll("[autocomplete]")).filter((el) => {
    const tagName = el.tagName.toLowerCase();
    return tagName === "input" || tagName === "select" || tagName === "textarea";
  });
  const res = [];
  for (const input of inputs) {
    if (!isVisible(input)) {
      continue;
    }
    const autocomplete = input.getAttribute("autocomplete") || "";
    if (!autocomplete || AUTOFILL_SKIP_TOKENS.has(autocomplete)) {
      continue;
    }
    const tokens = autocomplete.toLowerCase().split(" ");
    if (tokens.length > 3) {
      continue;
    }
    const field = tokens[tokens.length - 1];
    if (!AUTOFILL_TOKENS.has(field)) {
      continue;
    }
    tokens.pop();
    let section = SECTION_DEFAULT;
    if (tokens.length) {
      const sectionToken = tokens[tokens.length - 1];
      if (sectionToken === "shipping") {
        section = SECTION_SHIPPING;
        tokens.pop();
      }
      if (sectionToken === "billing") {
        section = SECTION_BILLING;
        tokens.pop();
      }
    }
    if (tokens.length) {
      const sectionToken = tokens[tokens.length - 1];
      if (sectionToken.startsWith(SECTION)) {
        section = sectionToken;
      }
    }
    res.push({
      input,
      section,
      field
    });
  }
  return res;
}
function findAddressAutofillInputs(form, ref) {
  const logicalSections = [];
  const logicalSectionSections = [];
  const formStructure = parseFormStructure(form);
  let foundSection = null;
  for (const { input, section, field } of formStructure) {
    let lastIndex = logicalSections.length - 1;
    let createNewSection = false;
    if (!logicalSections.length) {
      createNewSection = true;
    } else if (logicalSectionSections[lastIndex] !== section) {
      createNewSection = true;
    } else if (logicalSections[lastIndex][field]) {
      createNewSection = true;
    }
    if (createNewSection) {
      if (foundSection) {
        break;
      }
      logicalSections.push({
        [field]: input
      });
      logicalSectionSections.push(section);
      lastIndex++;
    } else {
      logicalSections[lastIndex][field] = input;
    }
    if (input === ref) {
      foundSection = logicalSections[lastIndex];
    }
  }
  return foundSection != null ? foundSection : {};
}
function setFormAutofillValues(form, ref, suggestion) {
  var _a;
  const map = findAddressAutofillInputs(form, ref);
  const streetAddress = [
    suggestion.address_line1,
    suggestion.address_line2,
    suggestion.address_line3
  ].filter((part) => Boolean(part)).join(", ");
  setValue(map["street-address"], streetAddress);
  setValue(map["address-line1"], suggestion.address_line1 || "");
  setValue(map["address-level1"], suggestion.address_level1 || "");
  setValue(map["address-level2"], suggestion.address_level2 || "");
  setValue(map["address-level3"], suggestion.address_level3 || "");
  const countryCode = suggestion.country_code || ((_a = suggestion.metadata) == null ? void 0 : _a.iso_3166_1) || "";
  if (map.country && map.country instanceof HTMLSelectElement) {
    let firstOption = map.country.querySelector(`option`).value;
    if (firstOption === "") {
      firstOption = map.country.querySelectorAll(`option`)[1].value;
    }
    const isUpperCase = firstOption === firstOption.toUpperCase();
    setValue(map["country"], isUpperCase ? countryCode.toUpperCase() : countryCode);
  } else {
    setValue(map["country"], countryCode);
  }
  setValue(map["country-name"], suggestion.country || "");
  setValue(map["postal-code"], suggestion.postcode || "");
}
function getFormAutofillValues(form, ref) {
  const map = findAddressAutofillInputs(form, ref);
  const values = {};
  for (const [key, input] of Object.entries(map)) {
    if (input == null ? void 0 : input.value) {
      values[key] = input.value;
    }
  }
  return values;
}
function getAutofillSearchText(snapshot) {
  const searchText = [];
  if (snapshot["street-address"]) {
    searchText.push(snapshot["street-address"]);
  } else {
    searchText.push(snapshot["address-line1"] || "");
    searchText.push(snapshot["address-line2"] || "");
    searchText.push(snapshot["address-line3"] || "");
  }
  searchText.push(snapshot["address-level3"] || "");
  searchText.push(snapshot["address-level2"] || "");
  searchText.push(snapshot["address-level1"] || "");
  searchText.push(snapshot["postal-code"] || "");
  if (snapshot["country-name"]) {
    searchText.push(snapshot["country-name"]);
  } else {
    searchText.push(snapshot["country"] || "");
  }
  return searchText.filter((part) => Boolean(part)).map((part) => part.trim()).join(", ");
}
function fillFormWithFeature(feature, input) {
  const form = findParentForm(input);
  if (!form) {
    return;
  }
  const suggestion = (0, import_search_js_core2.featureToSuggestion)(feature);
  setFormAutofillValues(form, input, suggestion);
  const inputMap = findAddressAutofillInputs(form, input);
  if (inputMap["address-line2"]) {
    inputMap["address-line2"].focus();
  }
}
function featureToAutofillValueMap(feature) {
  var _a;
  const values = {};
  const streetAddress = [
    feature.properties.address_line1,
    feature.properties.address_line2,
    feature.properties.address_line3
  ].filter((part) => Boolean(part)).join(", ");
  values["street-address"] = streetAddress;
  values["address-line1"] = feature.properties.address_line1;
  values["address-line2"] = feature.properties.address_line2;
  values["address-line3"] = feature.properties.address_line3;
  values["address-level1"] = feature.properties.address_level1;
  values["address-level2"] = feature.properties.address_level2;
  values["address-level3"] = feature.properties.address_level3;
  values["country"] = (_a = feature.properties.metadata) == null ? void 0 : _a.iso_3166_1;
  values["country-name"] = feature.properties.country;
  values["postal-code"] = feature.properties.postcode;
  return values;
}
function checkAutofillValuesChanged(targetMap, referenceMap) {
  for (const [key, value] of Object.entries(targetMap)) {
    if (referenceMap[key] !== value)
      return true;
  }
  return false;
}
var distinctExactStreetResults = (suggestions) => {
  return suggestions.filter((item1, idx, arr) => {
    const title = getSuggestionTitle(item1, 0 /* AddressAutofill */);
    return item1.accuracy !== "street" || arr.findIndex((item2) => title === getSuggestionTitle(item2, 0 /* AddressAutofill */)) === idx;
  });
};
var toggleAutocompletion = (input, initialAutocompleteValue, enableBrowserAutocomplete) => {
  const disableValue = "new-password";
  const defaultFallbackValue = "address-line1";
  const autocompleteValue = enableBrowserAutocomplete ? initialAutocompleteValue || defaultFallbackValue : disableValue;
  if (input) {
    input.autocomplete = autocompleteValue;
  }
};
var handleStreetSelection = (input, initialAutocompleteValue, suggestion) => {
  if (!input || !suggestion) {
    return;
  }
  toggleAutocompletion(input, initialAutocompleteValue, true);
  const feature = {
    properties: __spreadProps(__spreadValues({}, suggestion), {
      address_line1: suggestion.address_line1 + " ",
      postcode: null
    })
  };
  fillFormWithFeature(feature, input);
  toggleAutocompletion(input, initialAutocompleteValue, false);
  input == null ? void 0 : input.focus();
};

// src/confirmAddress.ts
var import_search_js_core5 = require("@mapbox/search-js-core");

// src/components/MapboxAddressConfirmation.ts
var import_search_js_core4 = require("@mapbox/search-js-core");
var import_no_scroll = __toESM(require("no-scroll"));
var import_focus_trap = require("focus-trap");

// src/config.ts
var import_search_js_core3 = require("@mapbox/search-js-core");
var Config = class {
  constructor() {
    this.feedbackEnabled = true;
    this.autofillSessionToken = new import_search_js_core3.SessionToken();
    this.autofillSessionEnabled = false;
    this.detectBrowserAutofillEnabled = false;
  }
};
var config = new Config();
Object.defineProperty(config, "autofillSessionToken", {
  configurable: false,
  writable: false
});

// src/components/MapboxAddressConfirmation.ts
var TEMPLATE = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmation" aria-hidden="true">
    <mapbox-address-confirmation-feature class="ContentFeature"></mapbox-address-confirmation-feature>
    <mapbox-address-confirmation-no-feature class="ContentNoFeature"></mapbox-address-confirmation-no-feature>
  </div>
</template>
`);
var _show, _binding2, _focusTrap, _themeInternal2;
var MapboxAddressConfirmation = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _show, false);
    __privateAdd(this, _binding2, void 0);
    __privateAdd(this, _focusTrap, void 0);
    __privateAdd(this, _themeInternal2, {});
  }
  get template() {
    return TEMPLATE;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmation", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal2);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal2, theme);
    if (!__privateGet(this, _binding2) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmation", theme));
    const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);
    ContentFeature.theme = theme;
    ContentNoFeature.theme = theme;
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding2, bindElements(this, {
      MapboxAddressConfirmation: ".MapboxAddressConfirmation",
      ContentFeature: ".ContentFeature",
      ContentNoFeature: ".ContentNoFeature"
    }));
    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);
    MapboxAddressConfirmation2.setAttribute("aria-hidden", "true");
    const theme = this.theme;
    if (theme) {
      const { ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);
      ContentFeature.theme = theme;
      ContentNoFeature.theme = theme;
    }
  }
  disconnectedCallback() {
    __privateSet(this, _focusTrap, null);
  }
  hide() {
    var _a;
    __privateSet(this, _show, false);
    if (!__privateGet(this, _binding2)) {
      return;
    }
    const { MapboxAddressConfirmation: MapboxAddressConfirmation2 } = __privateGet(this, _binding2);
    MapboxAddressConfirmation2.setAttribute("aria-hidden", "true");
    (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.deactivate();
    import_no_scroll.default.off();
  }
  show(autofillValues, optionsArg, feature) {
    return __async(this, null, function* () {
      var _a;
      if (!__privateGet(this, _binding2)) {
        return { type: "cancel" };
      }
      const { MapboxAddressConfirmation: MapboxAddressConfirmation2, ContentFeature, ContentNoFeature } = __privateGet(this, _binding2);
      const { accessToken, minimap = false, theme, footer } = optionsArg;
      this.theme = theme;
      if (feature) {
        ContentFeature.removeAttribute("aria-hidden");
        ContentNoFeature.setAttribute("aria-hidden", "true");
        ContentFeature.minimap = minimap;
        ContentFeature.accessToken = accessToken;
        ContentFeature.footer = footer;
        ContentFeature.update(feature, autofillValues);
      } else {
        ContentFeature.setAttribute("aria-hidden", "true");
        ContentNoFeature.removeAttribute("aria-hidden");
        ContentNoFeature.update(autofillValues);
      }
      __privateSet(this, _show, true);
      MapboxAddressConfirmation2.removeAttribute("aria-hidden");
      import_no_scroll.default.on();
      const activeContentElement = feature ? ContentFeature : ContentNoFeature;
      __privateSet(this, _focusTrap, (0, import_focus_trap.createFocusTrap)(MapboxAddressConfirmation2, {
        fallbackFocus: activeContentElement,
        escapeDeactivates: () => {
          this.hide();
          return true;
        }
      }));
      (_a = __privateGet(this, _focusTrap)) == null ? void 0 : _a.activate();
      return new Promise((resolve) => {
        const eventHost = activeContentElement;
        const fn = (e) => {
          eventHost.removeEventListener("result", fn);
          const result = e.detail;
          this.hide();
          if (result === "change") {
            resolve({
              type: "change",
              feature
            });
          } else {
            resolve({
              type: result
            });
          }
        };
        eventHost.addEventListener("result", fn);
      });
    });
  }
  tryShow(autofillValues, optionsArg) {
    return __async(this, null, function* () {
      if (!__privateGet(this, _binding2)) {
        return { type: "cancel" };
      }
      const { accessToken, options = {} } = optionsArg;
      const validate = new import_search_js_core4.ValidationCore(__spreadValues({
        accessToken
      }, options));
      const searchText = getAutofillSearchText(autofillValues);
      const featureCollection = yield validate.validate(searchText, {
        sessionToken: config.autofillSessionToken
      });
      const feature = featureCollection.features[0];
      if (feature) {
        const defaultValidation = (feature2) => feature2.properties.match_code.confidence === import_search_js_core4.MatchCodeConfidence.exact;
        const { skipConfirmModal = defaultValidation } = optionsArg;
        if (skipConfirmModal(feature)) {
          return { type: "nochange" };
        }
      }
      return yield this.show(autofillValues, optionsArg, feature);
    });
  }
};
_show = new WeakMap();
_binding2 = new WeakMap();
_focusTrap = new WeakMap();
_themeInternal2 = new WeakMap();
window.MapboxAddressConfirmation = MapboxAddressConfirmation;
if (!window.customElements.get("mapbox-address-confirmation")) {
  customElements.define("mapbox-address-confirmation", MapboxAddressConfirmation);
}

// src/confirmAddress.ts
var confirmation = new MapboxAddressConfirmation();
function confirmAddress(_0) {
  return __async(this, arguments, function* (form, optionsArg = {}) {
    const { sections = [] } = optionsArg;
    if (!confirmation.parentNode) {
      document.body.appendChild(confirmation);
    }
    let collectedResult = { type: "nochange" };
    const inputs = findAddressInputs(form);
    const structure = parseFormStructure(form);
    const listboxComponents = Array.from(document.querySelectorAll("mapbox-search-listbox"));
    for (const input of inputs) {
      if (sections.length) {
        const structureRef = structure.find((s) => s.input === input);
        if (!structureRef) {
          continue;
        }
        if (!sections.includes(structureRef.section)) {
          continue;
        }
      }
      const autofillValues = getFormAutofillValues(form, input);
      const listbox = listboxComponents.find((lb) => lb.input === input);
      const autofill2 = listbox == null ? void 0 : listbox.autofillHost;
      if (autofill2) {
        const lastRetrievedFeature = autofill2.retrieveFeature;
        if (lastRetrievedFeature) {
          const snapshot = featureToAutofillValueMap(lastRetrievedFeature);
          if (!checkAutofillValuesChanged(autofillValues, snapshot)) {
            continue;
          }
        }
      }
      const accessToken = optionsArg.accessToken || config.accessToken;
      const result = yield confirmation.tryShow(autofillValues, __spreadProps(__spreadValues({}, optionsArg), {
        accessToken
      }));
      if (result.type === "change") {
        if (listbox) {
          autofill2.simulateRetrieve(result.feature);
        } else {
          input.dataset["mapboxSuccess"] = "true";
          const suggestion = (0, import_search_js_core5.featureToSuggestion)(result.feature);
          setFormAutofillValues(form, input, suggestion);
        }
      }
      if (result.type === "change" && collectedResult.type !== "cancel") {
        collectedResult = result;
      }
      if (result.type === "cancel") {
        collectedResult = result;
      }
    }
    return collectedResult;
  });
}

// src/utils/confirmation.ts
function createAddressElement(autofillValues, baseAddress) {
  if (baseAddress) {
    const element = createElementFromString(`
        <span>
          <span></span>
          <br />
          <span></span>
        </span>
      `);
    const [firstLine, lastLine] = Array.from(element.querySelectorAll("span > span"));
    const parts = baseAddress.split(",");
    firstLine.textContent = parts[0].trim();
    lastLine.textContent = parts.slice(1).join(",").trim();
    if (autofillValues["address-line2"]) {
      const span = document.createElement("span");
      span.textContent = autofillValues["address-line2"];
      element.insertBefore(span, lastLine);
      element.insertBefore(document.createElement("br"), lastLine);
    }
    if (autofillValues["address-line3"]) {
      const span = document.createElement("span");
      span.textContent = autofillValues["address-line3"];
      element.insertBefore(span, lastLine);
      element.insertBefore(document.createElement("br"), lastLine);
    }
    return element;
  } else {
    const firstLine = autofillValues["street-address"] || autofillValues["address-line1"] || "";
    const line2 = autofillValues["address-line2"];
    const line3 = autofillValues["address-line3"];
    const lastLine = [
      autofillValues["address-level4"] || "",
      autofillValues["address-level3"] || "",
      autofillValues["address-level2"] || "",
      `${autofillValues["address-level1"] || ""} ${autofillValues["postal-code"] || ""}`,
      autofillValues.country || autofillValues["country-name"] || ""
    ].filter(Boolean).join(", ");
    const addressLines = [firstLine, line2, line3, lastLine].filter(Boolean);
    const addressLinesHtml = addressLines.map((val) => `<span>${val}</span>`).join("<br />");
    const element = createElementFromString(`
        <span>${addressLinesHtml}</span>
      `);
    return element;
  }
}
function tryConfirmBrowserAutofill(input, event, confirmOnBrowserAutofill, accessToken) {
  return __async(this, null, function* () {
    if (!confirmOnBrowserAutofill)
      return;
    const parentForm = findParentForm(input);
    const formElements = Object.values(findAddressAutofillInputs(parentForm, input));
    if (!event.detail.elements.some((el) => formElements.includes(el))) {
      return;
    }
    const structure = parseFormStructure(parentForm);
    const structureRef = structure.find((s) => s.input === input);
    const autofillInstanceSection = structureRef.section;
    const browserAutofilledSections = Array.from(new Set(structure.filter((s) => event.detail.elements.includes(s.input)).map((s) => s.section)));
    if (!browserAutofilledSections.includes(autofillInstanceSection)) {
      return;
    }
    const optionsSections = typeof confirmOnBrowserAutofill === "object" && confirmOnBrowserAutofill.sections || [];
    if (optionsSections.length && !optionsSections.some((section) => browserAutofilledSections.includes(section))) {
      return;
    }
    let optionsArg = typeof confirmOnBrowserAutofill === "object" ? confirmOnBrowserAutofill : {};
    optionsArg = __spreadProps(__spreadValues({}, optionsArg), {
      accessToken,
      sections: [autofillInstanceSection]
    });
    yield confirmAddress(parentForm, optionsArg);
  });
}

// src/utils/contribute.ts
var CONTRIBUTE_API_BASE_URL = "https://contribute-api.mapbox.com/v1";
var CONTRIBUTE_API_STAGING_BASE_URL = "https://contribute-api-staging.tilestream.net/v1";
var EDIT_SUGGESTION_ENDPOINT = "edit-suggestion";
function sendFeedback(accessToken, feedbackArgs) {
  if (!config.feedbackEnabled)
    return;
  const hostname = window.location.hostname;
  const BASE_URL = isLocalServer(hostname) || isMapboxDomain(hostname) ? CONTRIBUTE_API_STAGING_BASE_URL : CONTRIBUTE_API_BASE_URL;
  const url = `${BASE_URL}/${EDIT_SUGGESTION_ENDPOINT}/address?access_token=${accessToken}`;
  const { originalCoordinate, originalAddress, changes } = feedbackArgs;
  const payload = {
    action: "update",
    reason: "incorrect_address",
    location: {
      longitude: originalCoordinate[0],
      latitude: originalCoordinate[1]
    },
    userEmail: "no-reply-autofill@mapbox.com",
    changes,
    placeName: originalAddress
  };
  fetch(url, {
    method: "POST",
    headers: new Headers({
      "User-Agent": `mapbox-search-js.${version}.${navigator.userAgent}`,
      "Content-Type": "application/json"
    }),
    body: JSON.stringify(payload)
  });
}

// src/components/MapboxAddressConfirmationFeature.ts
var TEMPLATE2 = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmationFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Did you mean?</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>

      <div class="ModalAddress ModalAddressApprove"></div>
            
      <div class="ModalMap">
        <mapbox-address-minimap class="Minimap"></mapbox-address-minimap>
      </div>

      <div
        class="Button ButtonPrimary ButtonApprove"
        tabindex="0"
        role="button"
        aria-label="Yes"
      >
        Yes
      </div>
      
      <div
        class="Button ButtonSecondary ButtonReject"
        tabindex="0"
        role="button"
        aria-label="No, use the address I provided"
      >
        No, use the address I provided
      </div>

      <div class="ModalFooter">
          Your confirmation helps improve address data accuracy.
      </div>
    </div>
  </div>
</template>
`);
var _binding3, _themeInternal3, _feature, _formValues, _handleClose, _modalID, _modalHeaderTitleID, _modalAddressApproveID;
var MapboxAddressConfirmationFeature = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _binding3, void 0);
    __privateAdd(this, _themeInternal3, {});
    this.minimap = false;
    __privateAdd(this, _feature, void 0);
    __privateAdd(this, _formValues, void 0);
    this.update = (feature, autofillValues) => {
      __privateSet(this, _feature, feature);
      __privateSet(this, _formValues, autofillValues);
      const { ModalMap, Minimap, ModalAddressApprove } = __privateGet(this, _binding3);
      if (this.minimap) {
        ModalMap.removeAttribute("aria-hidden");
        Minimap.accessToken = this.accessToken;
        if (typeof this.minimap === "object") {
          const { defaultMapStyle, theme, mapStyleMode, satelliteToggle } = this.minimap;
          defaultMapStyle && (Minimap.defaultMapStyle = this.minimap.defaultMapStyle);
          theme && (Minimap.theme = this.minimap.theme);
          mapStyleMode && (Minimap.mapStyleMode = mapStyleMode);
          satelliteToggle !== void 0 && (Minimap.satelliteToggle = satelliteToggle);
        }
        Minimap.feature = feature;
      } else {
        ModalMap.setAttribute("aria-hidden", "true");
      }
      const approveAddress = feature.properties.place_name || feature.properties.full_address || feature.properties.address;
      ModalAddressApprove.innerHTML = "";
      ModalAddressApprove.appendChild(createAddressElement(autofillValues, approveAddress));
    };
    __privateAdd(this, _handleClose, () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "cancel"));
    });
    this.approve = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "change"));
    };
    this.reject = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "nochange"));
      sendFeedback(this.accessToken, {
        originalCoordinate: __privateGet(this, _feature).geometry.coordinates,
        originalAddress: __privateGet(this, _feature).properties.full_address,
        changes: {
          address: getAutofillSearchText(__privateGet(this, _formValues))
        }
      });
    };
    __privateAdd(this, _modalID, randomValidID());
    __privateAdd(this, _modalHeaderTitleID, randomValidID());
    __privateAdd(this, _modalAddressApproveID, randomValidID());
  }
  get template() {
    return TEMPLATE2;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmationFeature", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal3);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal3, theme);
    if (!__privateGet(this, _binding3) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmationFeature", theme));
    const { IconQuestion, IconClose } = __privateGet(this, _binding3);
    IconQuestion.innerHTML = getIcon("question", theme);
    IconClose.innerHTML = getIcon("close", theme);
  }
  set footer(val) {
    if (val === void 0)
      return;
    const footerEl = this.querySelector(".ModalFooter");
    if (typeof val === "string") {
      footerEl.textContent = val;
      footerEl.removeAttribute("aria-hidden");
    } else if (!val) {
      footerEl.setAttribute("aria-hidden", "true");
    } else {
      footerEl.removeAttribute("aria-hidden");
    }
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding3, bindElements(this, {
      MapboxAddressConfirmationFeature: ".MapboxAddressConfirmationFeature",
      Modal: ".Modal",
      ModalHeaderTitle: ".ModalHeaderTitle",
      ModalMap: ".ModalMap",
      Minimap: ".Minimap",
      IconQuestion: ".IconQuestion",
      IconClose: ".IconClose",
      ButtonApprove: ".ButtonApprove",
      ButtonReject: ".ButtonReject",
      ModalAddressApprove: ".ModalAddressApprove"
    }));
    const {
      Modal,
      ModalHeaderTitle,
      IconClose,
      ButtonApprove,
      ButtonReject,
      ModalAddressApprove
    } = __privateGet(this, _binding3);
    Modal.setAttribute("aria-labelledby", __privateGet(this, _modalHeaderTitleID));
    Modal.setAttribute("aria-describedby", __privateGet(this, _modalAddressApproveID));
    IconClose.setAttribute("aria-controls", __privateGet(this, _modalID));
    Modal.id = __privateGet(this, _modalID);
    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID);
    ModalAddressApprove.id = __privateGet(this, _modalAddressApproveID);
    const buttons = Array.from(this.querySelectorAll('[role="button"]'));
    for (const button of buttons) {
      button.addEventListener("keydown", ariaButtonKeyDown);
    }
    IconClose.addEventListener("click", __privateGet(this, _handleClose));
    ButtonApprove.addEventListener("click", this.approve);
    ButtonReject.addEventListener("click", this.reject);
    const theme = this.theme;
    if (theme) {
      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding3);
      IconQuestion.innerHTML = getIcon("question", theme);
      IconClose2.innerHTML = getIcon("close", theme);
    }
  }
  disconnectedCallback() {
    const { IconClose, ButtonApprove } = __privateGet(this, _binding3);
    IconClose.removeEventListener("click", __privateGet(this, _handleClose));
    ButtonApprove.removeEventListener("click", this.approve);
  }
};
_binding3 = new WeakMap();
_themeInternal3 = new WeakMap();
_feature = new WeakMap();
_formValues = new WeakMap();
_handleClose = new WeakMap();
_modalID = new WeakMap();
_modalHeaderTitleID = new WeakMap();
_modalAddressApproveID = new WeakMap();
window.MapboxAddressConfirmationFeature = MapboxAddressConfirmationFeature;
if (!window.customElements.get("mapbox-address-confirmation-feature")) {
  customElements.define("mapbox-address-confirmation-feature", MapboxAddressConfirmationFeature);
}

// src/components/MapboxAddressConfirmationNoFeature.ts
var TEMPLATE3 = createElementFromString(`
<template>
  <div class="MapboxAddressConfirmationNoFeature">
    <div class="Modal" aria-modal="true" role="dialog">
      <div class="ModalHeader">
        <svg viewBox="0 0 18 18" class="Icon IconQuestion"></svg>
        <div class="ModalHeaderTitle">Confirm address</div>
        <svg
          viewBox="0 0 18 18"
          class="Icon IconClose"
          tabindex="0"
          role="button"
          title="Close"
          aria-label="Close"
          aria-expanded="true"
        ></svg>
      </div>
      <div class="ModalDescription">
        We couldn't verify this address. Please check that your information is correct before continuing.
      </div>
      <br />
      <div class="ModalSubheader">
        You entered
      </div>
      <div class="ModalAddress"></div>
      <div
        class="Button ButtonPrimary"
        tabindex="0"
        role="button"
        aria-label="Use the address I provided"
      >
        Use the address I provided
      </div>
    </div>
  </div>
</template>
`);
var _binding4, _themeInternal4, _handleClose2, _modalID2, _modalHeaderTitleID2, _modalAddressID;
var MapboxAddressConfirmationNoFeature = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _binding4, void 0);
    __privateAdd(this, _themeInternal4, {});
    this.update = (autofillValues) => {
      const { ModalAddress } = __privateGet(this, _binding4);
      ModalAddress.innerHTML = "";
      ModalAddress.appendChild(createAddressElement(autofillValues));
    };
    __privateAdd(this, _handleClose2, () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "cancel"));
    });
    this.reject = () => {
      this.dispatchEvent(new MapboxHTMLEvent("result", "nochange"));
    };
    __privateAdd(this, _modalID2, randomValidID());
    __privateAdd(this, _modalHeaderTitleID2, randomValidID());
    __privateAdd(this, _modalAddressID, randomValidID());
  }
  get template() {
    return TEMPLATE3;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressConfirmationNoFeature", this.theme);
  }
  get theme() {
    return __privateGet(this, _themeInternal4);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal4, theme);
    if (!__privateGet(this, _binding4) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressConfirmationNoFeature", theme));
    const { IconQuestion, IconClose } = __privateGet(this, _binding4);
    IconQuestion.innerHTML = getIcon("question", theme);
    IconClose.innerHTML = getIcon("close", theme);
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding4, bindElements(this, {
      Modal: ".Modal",
      ModalHeaderTitle: ".ModalHeaderTitle",
      IconQuestion: ".IconQuestion",
      IconClose: ".IconClose",
      ModalAddress: ".ModalAddress",
      ButtonReject: ".Button"
    }));
    const { Modal, ModalHeaderTitle, IconClose, ModalAddress, ButtonReject } = __privateGet(this, _binding4);
    Modal.setAttribute("aria-labelledby", __privateGet(this, _modalHeaderTitleID2));
    Modal.setAttribute("aria-describedby", __privateGet(this, _modalAddressID));
    IconClose.setAttribute("aria-controls", __privateGet(this, _modalID2));
    Modal.id = __privateGet(this, _modalID2);
    ModalHeaderTitle.id = __privateGet(this, _modalHeaderTitleID2);
    ModalAddress.id = __privateGet(this, _modalAddressID);
    const buttons = Array.from(this.querySelectorAll('[role="button"]'));
    for (const button of buttons) {
      button.addEventListener("keydown", ariaButtonKeyDown);
    }
    IconClose.addEventListener("click", __privateGet(this, _handleClose2));
    ButtonReject.addEventListener("click", this.reject);
    const theme = this.theme;
    if (theme) {
      const { IconQuestion, IconClose: IconClose2 } = __privateGet(this, _binding4);
      IconQuestion.innerHTML = getIcon("question", theme);
      IconClose2.innerHTML = getIcon("close", theme);
    }
  }
  disconnectedCallback() {
    const { IconClose, ButtonReject } = __privateGet(this, _binding4);
    IconClose.removeEventListener("click", __privateGet(this, _handleClose2));
    ButtonReject.removeEventListener("click", this.reject);
  }
};
_binding4 = new WeakMap();
_themeInternal4 = new WeakMap();
_handleClose2 = new WeakMap();
_modalID2 = new WeakMap();
_modalHeaderTitleID2 = new WeakMap();
_modalAddressID = new WeakMap();
window.MapboxAddressConfirmationNoFeature = MapboxAddressConfirmationNoFeature;
if (!window.customElements.get("mapbox-address-confirmation-no-feature")) {
  customElements.define("mapbox-address-confirmation-no-feature", MapboxAddressConfirmationNoFeature);
}

// src/components/MapboxAddressAutofill.ts
var import_search_js_core7 = require("@mapbox/search-js-core");

// src/utils/detect_browser_autofill.ts
var import_search_js_core6 = require("@mapbox/search-js-core");

// src/utils/detect_browser_autofill.css
var detect_browser_autofill_default = 'input:-webkit-autofill,select:-webkit-autofill,textarea:-webkit-autofill{animation-name:onbrowserautofillstart}input:not(:-webkit-autofill),select:not(:-webkit-autofill),textarea:not(:-webkit-autofill){animation-name:onbrowserautofillcancel}@keyframes onbrowserautofillstart{0%{animation-name:"onbrowserautofillstart"}to{animation-name:"onbrowserautofillstart"}}@keyframes onbrowserautofillcancel{0%{animation-name:"onbrowserautofillcancel"}to{animation-name:"onbrowserautofillcancel"}}';

// src/utils/detect_browser_autofill.ts
var ATTR_NAME = "browser-autofilled";
var AUTOFILLED_ELEMENTS = [];
function dispatchBrowserAutofillEvent() {
  window.dispatchEvent(new window.CustomEvent("browserautofill", {
    bubbles: true,
    cancelable: true,
    detail: { elements: AUTOFILLED_ELEMENTS }
  }));
  AUTOFILLED_ELEMENTS = [];
}
var debouncedAutofill = (0, import_search_js_core6.debounce)(dispatchBrowserAutofillEvent, 5);
function browserAutofill(element) {
  if (element.hasAttribute(ATTR_NAME))
    return;
  element.setAttribute(ATTR_NAME, "");
  AUTOFILLED_ELEMENTS.push(element);
  debouncedAutofill();
}
function cancelBrowserAutofill(element) {
  if (!element.hasAttribute(ATTR_NAME))
    return;
  element.removeAttribute(ATTR_NAME);
}
function onAnimationStart(event) {
  event.animationName === "onbrowserautofillstart" ? browserAutofill(event.target) : cancelBrowserAutofill(event.target);
}
function onInput(event) {
  const targetEl = event.target;
  targetEl.nodeName.toLowerCase() !== "select" && !event.simulated && !(event instanceof MapboxHTMLEvent) && (event.inputType === "insertReplacementText" || !("data" in event)) ? browserAutofill(targetEl) : cancelBrowserAutofill(targetEl);
}
function initDetectBrowserAutofill() {
  if (config.detectBrowserAutofillEnabled) {
    return;
  } else {
    config.detectBrowserAutofillEnabled = true;
  }
  addDocumentStyle(detect_browser_autofill_default);
  document.addEventListener("animationstart", onAnimationStart, true);
  document.addEventListener("input", onInput, true);
}

// src/components/MapboxAddressAutofill.ts
var _autofill, _session, _input, _listbox, _initialAutocompleteValue, _browserAutofillEnabled, _handleSuggest, _handleSuggestError, _handleRetrieve, _handleObserve, _observer, _handleBrowserAutofill, _onHandleInput, _onHandleSelect, _onHandleBlur, _onHandleFocus;
var MapboxAddressAutofill = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _autofill, new import_search_js_core7.AddressAutofillCore());
    __privateAdd(this, _session, new import_search_js_core7.SearchSession(__privateGet(this, _autofill)));
    __privateAdd(this, _input, void 0);
    __privateAdd(this, _listbox, new MapboxSearchListbox());
    __privateAdd(this, _initialAutocompleteValue, void 0);
    this.options = {};
    this.confirmOnBrowserAutofill = false;
    __privateAdd(this, _browserAutofillEnabled, false);
    __privateAdd(this, _handleSuggest, (result) => {
      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;
      __privateGet(this, _listbox).handleSuggest(filteredSuggestions);
      this.dispatchEvent(new MapboxHTMLEvent("suggest", result));
    });
    __privateAdd(this, _handleSuggestError, (error) => {
      __privateGet(this, _listbox).handleError();
      this.dispatchEvent(new MapboxHTMLEvent("suggesterror", error));
    });
    __privateAdd(this, _handleRetrieve, (result) => {
      var _a;
      this.dispatchEvent(new MapboxHTMLEvent("retrieve", result));
      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];
      if (!__privateGet(this, _input)) {
        return;
      }
      const featureCollection = result;
      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {
        return;
      }
      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input));
    });
    __privateAdd(this, _handleObserve, () => {
      var _a;
      try {
        const input = (_a = this.querySelector("input")) != null ? _a : null;
        __privateSet(this, _input, input);
        __privateGet(this, _listbox).input = input;
      } catch (e) {
        __privateSet(this, _input, null);
        __privateGet(this, _listbox).input = null;
        console.error(e.message || e);
      }
    });
    __privateAdd(this, _observer, new MutationObserver(__privateGet(this, _handleObserve)));
    __privateAdd(this, _handleBrowserAutofill, (e) => {
      __privateGet(this, _listbox).blur();
      tryConfirmBrowserAutofill(__privateGet(this, _input), e, this.confirmOnBrowserAutofill, this.accessToken);
    });
    this.retrieveFeature = null;
    this.interceptSearch = null;
    __privateAdd(this, _onHandleInput, (e) => {
      this.dispatchEvent(e.clone());
      const inputText = e.detail;
      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && (inputText == null ? void 0 : inputText.length) <= 2;
      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);
      const alteredText = this.interceptSearch && this.interceptSearch(inputText);
      const searchText = this.interceptSearch ? alteredText : inputText;
      if (this.interceptSearch && !alteredText || (searchText == null ? void 0 : searchText.length) <= 2) {
        __privateGet(this, _listbox).handleSuggest(null);
        return;
      }
      __privateGet(this, _session).suggest(searchText, this.options);
    });
    __privateAdd(this, _onHandleSelect, (e) => {
      const suggestion = e.detail;
      if (e.detail.accuracy !== "street") {
        toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);
        __privateGet(this, _session).retrieve(suggestion, this.options);
      } else {
        handleStreetSelection(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), suggestion);
      }
    });
    __privateAdd(this, _onHandleBlur, () => {
      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), true);
      __privateGet(this, _session).abort();
    });
    __privateAdd(this, _onHandleFocus, () => {
      var _a;
      const enableBrowserAutocomplete = this.browserAutofillEnabled === true && ((_a = __privateGet(this, _input).value) == null ? void 0 : _a.length) <= 2;
      toggleAutocompletion(__privateGet(this, _input), __privateGet(this, _initialAutocompleteValue), enableBrowserAutocomplete);
    });
  }
  get accessToken() {
    return __privateGet(this, _autofill).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _autofill).accessToken = newToken;
  }
  get input() {
    return __privateGet(this, _input);
  }
  get theme() {
    return __privateGet(this, _listbox).theme;
  }
  set theme(theme) {
    __privateGet(this, _listbox).theme = theme;
  }
  get popoverOptions() {
    return __privateGet(this, _listbox).popoverOptions;
  }
  set popoverOptions(newOptions) {
    __privateGet(this, _listbox).popoverOptions = newOptions;
  }
  get browserAutofillEnabled() {
    return __privateGet(this, _browserAutofillEnabled);
  }
  set browserAutofillEnabled(enable) {
    __privateSet(this, _browserAutofillEnabled, enable);
  }
  connectedCallback() {
    var _a;
    super.connectedCallback();
    config.autofillSessionEnabled = true;
    __privateGet(this, _session).sessionToken = config.autofillSessionToken;
    __privateGet(this, _listbox).autofillHost = this;
    __privateGet(this, _listbox).searchService = 0 /* AddressAutofill */;
    const input = (_a = this.querySelector("input")) != null ? _a : null;
    __privateGet(this, _observer).observe(this, {
      subtree: true,
      childList: true
    });
    __privateGet(this, _handleObserve).call(this);
    __privateGet(this, _listbox).addEventListener("input", __privateGet(this, _onHandleInput));
    __privateGet(this, _listbox).addEventListener("select", __privateGet(this, _onHandleSelect));
    __privateGet(this, _listbox).addEventListener("blur", __privateGet(this, _onHandleBlur));
    __privateGet(this, _listbox).addEventListener("focus", __privateGet(this, _onHandleFocus));
    __privateGet(this, _session).addEventListener("suggest", __privateGet(this, _handleSuggest));
    __privateGet(this, _session).addEventListener("suggesterror", __privateGet(this, _handleSuggestError));
    __privateGet(this, _session).addEventListener("retrieve", __privateGet(this, _handleRetrieve));
    document.body.appendChild(__privateGet(this, _listbox));
    if (input) {
      input.insertAdjacentElement("beforebegin", createAriaLiveElement(__privateGet(this, _listbox).dataSeed));
      suppressExtensionsAutocomplete(input);
      __privateSet(this, _initialAutocompleteValue, input.autocomplete);
    }
    initDetectBrowserAutofill();
    window.addEventListener("browserautofill", __privateGet(this, _handleBrowserAutofill));
  }
  disconnectedCallback() {
    __privateGet(this, _listbox).remove();
    __privateGet(this, _listbox).removeEventListener("input", __privateGet(this, _onHandleInput));
    __privateGet(this, _listbox).removeEventListener("select", __privateGet(this, _onHandleSelect));
    __privateGet(this, _listbox).removeEventListener("blur", __privateGet(this, _onHandleBlur));
    __privateGet(this, _listbox).removeEventListener("focus", __privateGet(this, _onHandleFocus));
    __privateGet(this, _session).removeEventListener("suggest", __privateGet(this, _handleSuggest));
    __privateGet(this, _session).removeEventListener("suggesterror", __privateGet(this, _handleSuggestError));
    __privateGet(this, _session).removeEventListener("retrieve", __privateGet(this, _handleRetrieve));
    __privateGet(this, _observer).disconnect();
    window.removeEventListener("browserautofill", __privateGet(this, _handleBrowserAutofill));
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      __privateGet(this, _autofill).accessToken = newValue;
      return;
    }
    if (name === "browser-autofill-enabled") {
      __privateSet(this, _browserAutofillEnabled, Boolean(newValue));
      return;
    }
    if (name === "theme") {
      this.theme = tryParseJSON(newValue);
      return;
    }
    if (name === "popover-options") {
      this.popoverOptions = tryParseJSON(newValue);
      return;
    }
    const optionName = name.split("-").join("_");
    if (!newValue) {
      delete this.options[optionName];
    }
    this.options[optionName] = newValue;
  }
  focus() {
    __privateGet(this, _listbox).focus();
  }
  simulateRetrieve(feature) {
    const input = this.input;
    if (input) {
      input.dataset["mapboxSuccess"] = "true";
    }
    __privateGet(this, _listbox).hideResults();
    const simResult = {
      type: "FeatureCollection",
      features: [feature],
      url: ""
    };
    __privateGet(this, _handleRetrieve).call(this, simResult);
  }
};
_autofill = new WeakMap();
_session = new WeakMap();
_input = new WeakMap();
_listbox = new WeakMap();
_initialAutocompleteValue = new WeakMap();
_browserAutofillEnabled = new WeakMap();
_handleSuggest = new WeakMap();
_handleSuggestError = new WeakMap();
_handleRetrieve = new WeakMap();
_handleObserve = new WeakMap();
_observer = new WeakMap();
_handleBrowserAutofill = new WeakMap();
_onHandleInput = new WeakMap();
_onHandleSelect = new WeakMap();
_onHandleBlur = new WeakMap();
_onHandleFocus = new WeakMap();
MapboxAddressAutofill.observedAttributes = [
  "access-token",
  "browser-autofill-enabled",
  "theme",
  "popover-options",
  "css-text",
  "language",
  "country",
  "bbox",
  "limit",
  "proximity",
  "streets"
];
window.MapboxAddressAutofill = MapboxAddressAutofill;
if (!window.customElements.get("mapbox-address-autofill")) {
  customElements.define("mapbox-address-autofill", MapboxAddressAutofill);
}

// src/components/MapboxSearchBox.ts
var import_search_js_core8 = require("@mapbox/search-js-core");
var import_subtag = __toESM(require("subtag"));

// src/utils/localization.ts
var placeholder = {
  de: "Suche",
  it: "Ricerca",
  en: "Search",
  nl: "Zoeken",
  fr: "Chercher",
  ca: "Cerca",
  he: "\u05DC\u05D7\u05E4\u05E9",
  ja: "\u30B5\u30FC\u30C1",
  lv: "Mekl\u0113t",
  pt: "Procurar",
  sr: "\u041F\u0440\u0435\u0442\u0440\u0430\u0433\u0430",
  zh: "\u641C\u7D22",
  cs: "Vyhled\xE1v\xE1n\xED",
  hu: "Keres\xE9s",
  ka: "\u10EB\u10D8\u10D4\u10D1\u10D0",
  nb: "S\xF8ke",
  sk: "Vyh\u013Ead\xE1vanie",
  th: "\u0E04\u0E49\u0E19\u0E2B\u0E32",
  fi: "Hae",
  is: "Leita",
  ko: "\uC218\uC0C9",
  pl: "Szukaj",
  sl: "Iskanje",
  fa: "\u062C\u0633\u062A\u062C\u0648",
  ru: "\u041F\u043E\u0438\u0441\u043A"
};
var localization_default = { placeholder };

// src/components/MapboxSearchBox.ts
var MAX_ZOOM = 9;
var _binding5, _search, _session2, _map, _input2, _listbox2, _getDefaultPlaceholder, getDefaultPlaceholder_fn, _placeholder, _handleSuggest2, _handleSuggestError2, _handleRetrieve2, _mapMarker, _removeMarker, _handleMarker, _onHandleInput2, _onHandleSelect2, _onHandleBlur2, _setActionIcons, _handleClear, _handleMoveEnd;
var MapboxSearchBox = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _getDefaultPlaceholder);
    __privateAdd(this, _binding5, void 0);
    __privateAdd(this, _search, new import_search_js_core8.SearchBoxCore({}));
    __privateAdd(this, _session2, new import_search_js_core8.SearchSession(__privateGet(this, _search)));
    __privateAdd(this, _map, null);
    __privateAdd(this, _input2, void 0);
    __privateAdd(this, _listbox2, new MapboxSearchListbox());
    this.options = {};
    __privateAdd(this, _placeholder, void 0);
    __privateAdd(this, _handleSuggest2, (result) => {
      __privateGet(this, _setActionIcons).call(this);
      __privateGet(this, _listbox2).handleSuggest((result == null ? void 0 : result.suggestions) || null);
      this.dispatchEvent(new MapboxHTMLEvent("suggest", result));
    });
    __privateAdd(this, _handleSuggestError2, (error) => {
      __privateGet(this, _setActionIcons).call(this);
      __privateGet(this, _listbox2).handleError();
      this.dispatchEvent(new MapboxHTMLEvent("suggesterror", error));
    });
    __privateAdd(this, _handleRetrieve2, (result) => {
      __privateGet(this, _setActionIcons).call(this);
      this.dispatchEvent(new MapboxHTMLEvent("retrieve", result));
      const featureCollection = result;
      if (!featureCollection || !featureCollection.features.length) {
        return;
      }
      const suggestion = (0, import_search_js_core8.featureToSuggestion)(featureCollection.features[0]);
      __privateGet(this, _input2).value = suggestion.name;
      const map = __privateGet(this, _map);
      if (!map) {
        return;
      }
      const feature = featureCollection.features[0];
      if (!feature) {
        return;
      }
      const placeType = feature.properties.feature_type;
      const bounds = feature.properties.bbox;
      if (bounds) {
        map.flyTo(bboxViewport(map, import_search_js_core8.LngLatBounds.convert(bounds).toFlatArray()));
      } else {
        const center = feature.geometry.coordinates;
        const zoom = getMaxZoom(placeType);
        map.flyTo({
          center,
          zoom,
          speed: FLY_TO_SPEED
        });
      }
      if (this.marker && this.mapboxgl) {
        __privateGet(this, _handleMarker).call(this, feature);
      }
    });
    __privateAdd(this, _mapMarker, void 0);
    __privateAdd(this, _removeMarker, () => {
      if (__privateGet(this, _mapMarker)) {
        __privateGet(this, _mapMarker).remove();
        __privateSet(this, _mapMarker, null);
      }
    });
    __privateAdd(this, _handleMarker, (feature) => {
      if (!__privateGet(this, _map)) {
        return;
      }
      __privateGet(this, _removeMarker).call(this);
      if (!feature)
        return;
      const defaultMarkerOptions = {
        color: "#4668F2"
      };
      const markerOptions = __spreadValues(__spreadValues({}, defaultMarkerOptions), typeof this.marker === "object" && this.marker);
      __privateSet(this, _mapMarker, new this.mapboxgl.Marker(markerOptions));
      if (feature.geometry && feature.geometry.type && feature.geometry.type === "Point" && feature.geometry.coordinates) {
        __privateGet(this, _mapMarker).setLngLat(feature.geometry.coordinates).addTo(__privateGet(this, _map));
      }
    });
    this.interceptSearch = null;
    __privateAdd(this, _onHandleInput2, (e) => {
      this.dispatchEvent(e.clone());
      const inputText = e.detail;
      if (!inputText) {
        __privateGet(this, _handleClear).call(this);
        return;
      }
      const alteredText = this.interceptSearch && this.interceptSearch(inputText);
      const searchText = this.interceptSearch ? alteredText : inputText;
      if (this.interceptSearch && !alteredText) {
        __privateGet(this, _listbox2).hideResults();
        return;
      }
      __privateGet(this, _session2).suggest(searchText, this.options);
      __privateGet(this, _setActionIcons).call(this, true);
    });
    __privateAdd(this, _onHandleSelect2, (e) => {
      const suggestion = e.detail;
      __privateGet(this, _session2).retrieve(suggestion, this.options);
      __privateGet(this, _setActionIcons).call(this, true);
    });
    __privateAdd(this, _onHandleBlur2, () => {
      __privateGet(this, _session2).abort();
    });
    __privateAdd(this, _setActionIcons, (loading = false) => {
      if (loading) {
        __privateGet(this, _binding5).ClearBtn.style.display = "none";
        __privateGet(this, _binding5).LoadingIcon.style.display = "block";
      } else {
        __privateGet(this, _binding5).LoadingIcon.style.display = "none";
        __privateGet(this, _binding5).ClearBtn.style.display = this.value ? "block" : "none";
      }
    });
    __privateAdd(this, _handleClear, () => {
      this.value = "";
      __privateGet(this, _setActionIcons).call(this);
      __privateGet(this, _handleMarker).call(this, null);
      __privateGet(this, _listbox2).handleSuggest(null);
    });
    this.marker = true;
    __privateAdd(this, _handleMoveEnd, () => {
      const map = __privateGet(this, _map);
      const options = __spreadValues({}, this.options);
      if (map.getZoom() <= MAX_ZOOM) {
        delete options.proximity;
        this.options = options;
        return;
      }
      const center = map.getCenter();
      this.options = __spreadProps(__spreadValues({}, options), {
        proximity: center
      });
    });
  }
  get accessToken() {
    return __privateGet(this, _search).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _search).accessToken = newToken;
  }
  get value() {
    return __privateGet(this, _input2).value;
  }
  set value(newValue) {
    __privateGet(this, _input2).value = newValue;
  }
  get input() {
    return __privateGet(this, _input2);
  }
  get template() {
    return SEARCHBOX_TEMPLATE;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".SearchBox", __privateGet(this, _listbox2).theme);
  }
  get theme() {
    return __privateGet(this, _listbox2).theme;
  }
  set theme(theme) {
    __privateGet(this, _listbox2).theme = theme;
    if (!__privateGet(this, _binding5) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".SearchBox", theme));
    __privateGet(this, _listbox2).updatePopover();
    const { SearchIcon } = __privateGet(this, _binding5);
    SearchIcon.innerHTML = getIcon("search", theme);
  }
  get popoverOptions() {
    return __privateGet(this, _listbox2).popoverOptions;
  }
  set popoverOptions(newOptions) {
    __privateGet(this, _listbox2).popoverOptions = newOptions;
  }
  get placeholder() {
    return __privateGet(this, _placeholder) || __privateMethod(this, _getDefaultPlaceholder, getDefaultPlaceholder_fn).call(this);
  }
  set placeholder(text) {
    __privateSet(this, _placeholder, text);
    if (__privateGet(this, _input2)) {
      __privateGet(this, _input2).placeholder = this.placeholder;
      __privateGet(this, _input2).setAttribute("aria-label", this.placeholder);
    }
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding5, bindElements(this, {
      SearchBox: ".SearchBox",
      SearchIcon: ".SearchIcon",
      Input: ".Input",
      ClearBtn: ".ClearBtn",
      LoadingIcon: ".LoadingIcon"
    }));
    this.theme = __spreadValues({}, this.theme);
    const { Input, ClearBtn } = __privateGet(this, _binding5);
    __privateSet(this, _input2, Input);
    __privateGet(this, _listbox2).input = Input;
    __privateGet(this, _listbox2).searchService = 3 /* SearchBox */;
    __privateGet(this, _listbox2).addEventListener("input", __privateGet(this, _onHandleInput2));
    __privateGet(this, _listbox2).addEventListener("select", __privateGet(this, _onHandleSelect2));
    __privateGet(this, _listbox2).addEventListener("blur", __privateGet(this, _onHandleBlur2));
    __privateGet(this, _session2).addEventListener("suggest", __privateGet(this, _handleSuggest2));
    __privateGet(this, _session2).addEventListener("suggesterror", __privateGet(this, _handleSuggestError2));
    __privateGet(this, _session2).addEventListener("retrieve", __privateGet(this, _handleRetrieve2));
    ClearBtn.addEventListener("click", __privateGet(this, _handleClear));
    this.placeholder = __privateGet(this, _placeholder);
    document.body.appendChild(__privateGet(this, _listbox2));
    if (Input) {
      if (Input.previousElementSibling.hasAttribute("aria-live")) {
        Input.previousElementSibling.remove();
      }
      Input.insertAdjacentElement("beforebegin", createAriaLiveElement(__privateGet(this, _listbox2).dataSeed));
    }
  }
  disconnectedCallback() {
    __privateGet(this, _listbox2).remove();
    __privateGet(this, _listbox2).input = null;
    __privateGet(this, _listbox2).removeEventListener("input", __privateGet(this, _onHandleInput2));
    __privateGet(this, _listbox2).removeEventListener("select", __privateGet(this, _onHandleSelect2));
    __privateGet(this, _listbox2).removeEventListener("blur", __privateGet(this, _onHandleBlur2));
    __privateGet(this, _session2).removeEventListener("suggest", __privateGet(this, _handleSuggest2));
    __privateGet(this, _session2).removeEventListener("suggesterror", __privateGet(this, _handleSuggestError2));
    __privateGet(this, _session2).removeEventListener("retrieve", __privateGet(this, _handleRetrieve2));
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      __privateGet(this, _search).accessToken = newValue;
      return;
    }
    if (name === "theme") {
      this.theme = tryParseJSON(newValue);
      return;
    }
    if (name === "popover-options") {
      this.popoverOptions = tryParseJSON(newValue);
      return;
    }
    if (name === "placeholder") {
      this.placeholder = newValue;
      return;
    }
    const optionName = name.split("-").join("_");
    if (!newValue) {
      delete this.options[optionName];
    }
    this.options[optionName] = newValue;
    if (optionName === "language") {
      this.placeholder = __privateGet(this, _placeholder);
    }
  }
  focus() {
    __privateGet(this, _listbox2).focus();
  }
  search(text) {
    this.value = text;
    __privateGet(this, _onHandleInput2).call(this, new MapboxHTMLEvent("input", text));
  }
  bindMap(map) {
    if (__privateGet(this, _map)) {
      __privateGet(this, _map).off("moveend", __privateGet(this, _handleMoveEnd));
    }
    if (map) {
      map.on("moveend", __privateGet(this, _handleMoveEnd));
    }
    __privateSet(this, _map, map);
  }
  unbindMap() {
    this.bindMap(null);
  }
  onAdd(map) {
    this.bindMap(map);
    this.remove();
    const container = document.createElement("div");
    container.className = "mapboxgl-ctrl";
    container.style.width = "300px";
    container.appendChild(this);
    return container;
  }
  onRemove() {
    this.remove();
    this.unbindMap();
    __privateGet(this, _removeMarker).call(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
};
_binding5 = new WeakMap();
_search = new WeakMap();
_session2 = new WeakMap();
_map = new WeakMap();
_input2 = new WeakMap();
_listbox2 = new WeakMap();
_getDefaultPlaceholder = new WeakSet();
getDefaultPlaceholder_fn = function() {
  if (this.options.language) {
    const firstLanguage = this.options.language.split(",")[0];
    const language = import_subtag.default.language(firstLanguage);
    const localizedValue = localization_default.placeholder[language];
    if (localizedValue)
      return localizedValue;
  }
  return "Search";
};
_placeholder = new WeakMap();
_handleSuggest2 = new WeakMap();
_handleSuggestError2 = new WeakMap();
_handleRetrieve2 = new WeakMap();
_mapMarker = new WeakMap();
_removeMarker = new WeakMap();
_handleMarker = new WeakMap();
_onHandleInput2 = new WeakMap();
_onHandleSelect2 = new WeakMap();
_onHandleBlur2 = new WeakMap();
_setActionIcons = new WeakMap();
_handleClear = new WeakMap();
_handleMoveEnd = new WeakMap();
MapboxSearchBox.observedAttributes = [
  "access-token",
  "theme",
  "popover-options",
  "placeholder",
  "language",
  "country",
  "bbox",
  "limit",
  "navigation-profile",
  "origin",
  "proximity",
  "eta-type",
  "types"
];
window.MapboxSearchBox = MapboxSearchBox;
if (!window.customElements.get("mapbox-search-box")) {
  customElements.define("mapbox-search-box", MapboxSearchBox);
}

// src/components/MapboxAddressMinimap.ts
var import_search_js_core9 = require("@mapbox/search-js-core");

// src/utils/minimap.ts
var import_sphericalmercator = __toESM(require("@mapbox/sphericalmercator"));
var merc = new import_sphericalmercator.default({ size: 512, antimeridian: true });
var MAX_IMAGE_DIM = 1280;
function getAnchorOffset(marker, anchor) {
  const { width, height } = getElementSize(marker, true);
  switch (anchor) {
    case "center":
      return [0, 0];
    case "top":
      return [0, height / 2];
    case "bottom":
      return [0, -1 * height / 2];
    case "left":
      return [width / 2, 0];
    case "right":
      return [-1 * width / 2, 0];
    case "top-left":
      return [width / 2, height / 2];
    case "top-right":
      return [-1 * width / 2, height / 2];
    case "bottom-left":
      return [width / 2, -1 * height / 2];
    case "bottom-right":
      return [-1 * width / 2, -1 * height / 2];
  }
}
var _anchor, _handleAnchorResize, _markerTransform, _isActive, _originalCoordinate, _onPointerDownMarker, _onPointerUpMarker, _onPointerMoveMarker, _onPointerDownImage, _onPointerUpImage, _onPointerMoveImage, _updatePointerPosition, _updateMarkerTransform, _updateMarkerCorrection;
var MarkerController = class {
  constructor(imageContainer, imageElement, marker, keepMarkerCentered, zoom, anchor) {
    __privateAdd(this, _anchor, void 0);
    __privateAdd(this, _handleAnchorResize, () => {
      [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, this.anchor);
      this.markerTransform = {
        anchorX: this.anchorOffsetX,
        anchorY: this.anchorOffsetY
      };
    });
    __privateAdd(this, _markerTransform, {
      anchorX: 0,
      anchorY: 0,
      globalX: 0,
      globalY: 0,
      correctionX: 0,
      correctionY: 0
    });
    __privateAdd(this, _isActive, false);
    __privateAdd(this, _originalCoordinate, void 0);
    __privateAdd(this, _onPointerDownMarker, (m) => {
      if (!this.isActive)
        return;
      m.preventDefault();
      m.stopPropagation();
      __privateGet(this, _updatePointerPosition).call(this, m);
      window.addEventListener("pointermove", __privateGet(this, _onPointerMoveMarker));
      window.addEventListener("pointerup", __privateGet(this, _onPointerUpMarker));
    });
    __privateAdd(this, _onPointerUpMarker, () => {
      window.removeEventListener("pointermove", __privateGet(this, _onPointerMoveMarker));
      window.removeEventListener("pointerup", __privateGet(this, _onPointerUpMarker));
    });
    __privateAdd(this, _onPointerMoveMarker, (m) => {
      m.preventDefault();
      m.stopPropagation();
      const diffX = this.curPointerXPos - m.pageX;
      const diffY = this.curPointerYPos - m.pageY;
      this.markerDeltaX += diffX;
      this.markerDeltaY -= diffY;
      this.markerDeltaX = Math.max(Math.min(this.imgElement.width / 2, this.markerDeltaX), this.imgElement.width / 2 * -1);
      this.markerDeltaY = Math.max(Math.min(this.imgElement.height / 2, this.markerDeltaY), this.imgElement.height / 2 * -1);
      const imageOffsetX = this.imgCenterPx[0] - this.imgCenterAdjustedPx[0];
      const imageOffsetY = this.imgCenterPx[1] - this.imgCenterAdjustedPx[1];
      const deltaX = this.markerDeltaX - imageOffsetX;
      const deltaY = this.markerDeltaY + imageOffsetY;
      this.markerTransform = { globalX: deltaX, globalY: deltaY };
      __privateGet(this, _updatePointerPosition).call(this, m);
    });
    __privateAdd(this, _onPointerDownImage, (m) => {
      if (!this.isActive)
        return;
      m.preventDefault();
      m.stopPropagation();
      __privateGet(this, _updatePointerPosition).call(this, m);
      window.addEventListener("pointermove", __privateGet(this, _onPointerMoveImage));
      window.addEventListener("pointerup", __privateGet(this, _onPointerUpImage));
    });
    __privateAdd(this, _onPointerUpImage, () => {
      window.removeEventListener("pointermove", __privateGet(this, _onPointerMoveImage));
      window.removeEventListener("pointerup", __privateGet(this, _onPointerUpImage));
    });
    __privateAdd(this, _onPointerMoveImage, (m) => {
      m.preventDefault();
      let top = Math.round(this.imgContainerElement.scrollTop + (this.curPointerYPos - m.pageY));
      top = Math.max(Math.min(this.imgElement.height - this.imgContainerElement.clientHeight, top), 0);
      let left = Math.round(this.imgContainerElement.scrollLeft + (this.curPointerXPos - m.pageX));
      left = Math.max(Math.min(this.imgElement.width - this.imgContainerElement.clientWidth, left), 0);
      this.imgContainerElement.scrollTop = top;
      this.imgContainerElement.scrollLeft = left;
      const diffX = Math.round(left - (this.imgElement.width - this.imgContainerElement.clientWidth) / 2);
      const diffY = Math.round((this.imgElement.height - this.imgContainerElement.clientHeight) / 2 - top);
      this.imgCenterAdjustedPx = [
        this.imgCenterPx[0] + diffX,
        this.imgCenterPx[1] - diffY
      ];
      if (!this.keepMarkerCentered) {
        const deltaX = this.markerDeltaX + diffX;
        const deltaY = this.markerDeltaY + diffY;
        this.markerTransform = { globalX: deltaX, globalY: deltaY };
      }
      __privateGet(this, _updateMarkerCorrection).call(this, left, top);
      __privateGet(this, _updatePointerPosition).call(this, m);
    });
    __privateAdd(this, _updatePointerPosition, (m) => {
      this.curPointerXPos = m.pageX;
      this.curPointerYPos = m.pageY;
    });
    __privateAdd(this, _updateMarkerTransform, () => {
      const { anchorX, anchorY, globalX, globalY, correctionX, correctionY } = __privateGet(this, _markerTransform);
      const transformX = anchorX - globalX + correctionX;
      const transformY = anchorY + globalY + correctionY;
      this.markerElement.style.transform = `translate(calc(-50% + ${transformX}px), calc(-50% + ${transformY}px))`;
    });
    this.reCenter = () => {
      const top = (this.imgElement.height - this.imgContainerElement.clientHeight) / 2;
      const left = (this.imgElement.width - this.imgContainerElement.clientWidth) / 2;
      this.imgContainerElement.scrollTop = top;
      this.imgContainerElement.scrollLeft = left;
      this.imgCenterAdjustedPx = this.imgCenterPx;
      this.markerDeltaX = this.markerDeltaY = 0;
      this.markerTransform = {
        globalX: 0,
        globalY: 0,
        correctionX: 0,
        correctionY: 0
      };
    };
    this.handleMinimapResize = () => {
      if (!this.imgElement.height || !this.imgElement.width)
        return;
      const centerOffsetX = this.imgCenterOffset.x;
      const centerOffsetY = this.imgCenterOffset.y;
      const left = this.imgElement.width / 2 - centerOffsetX - this.imgContainerElement.clientWidth / 2;
      const top = this.imgElement.height / 2 - centerOffsetY - this.imgContainerElement.clientHeight / 2;
      this.imgContainerElement.scrollLeft = left;
      this.imgContainerElement.scrollTop = top;
      __privateGet(this, _updateMarkerCorrection).call(this, left, top);
    };
    __privateAdd(this, _updateMarkerCorrection, (scrollLeft, scrollTop) => {
      const centerOffsetX = this.imgCenterOffset.x;
      const centerOffsetY = this.imgCenterOffset.y;
      const { correctionX, correctionY } = this.markerTransform;
      const corrections = {};
      if (scrollLeft / 2 < centerOffsetX * -1) {
        const markerTranslateX = centerOffsetX * -1 - scrollLeft / 2;
        corrections.correctionX = markerTranslateX * 2;
      } else if (scrollLeft < 0) {
        corrections.correctionX = scrollLeft;
      } else if (correctionX !== 0) {
        corrections.correctionX = 0;
      }
      if (scrollTop / 2 < centerOffsetY * -1) {
        const markerTranslateY = centerOffsetY * -1 - scrollTop / 2;
        corrections.correctionY = markerTranslateY * 2;
      } else if (scrollTop < 0) {
        corrections.correctionY = scrollTop;
      } else if (correctionY !== 0) {
        corrections.correctionY = 0;
      }
      this.markerTransform = corrections;
    });
    this.markerElement = marker;
    this.imgContainerElement = imageContainer;
    this.imgElement = imageElement;
    this.keepMarkerCentered = keepMarkerCentered;
    this.zoom = zoom;
    this.anchor = anchor;
    this.curPointerXPos = 0;
    this.curPointerYPos = 0;
    this.markerDeltaX = 0;
    this.markerDeltaY = 0;
    this.imgContainerElement.addEventListener("pointerdown", __privateGet(this, _onPointerDownImage));
    if (!this.keepMarkerCentered) {
      this.markerElement.addEventListener("pointerdown", __privateGet(this, _onPointerDownMarker));
    }
    const resizeObserver = new ResizeObserver(__privateGet(this, _handleAnchorResize));
    resizeObserver.observe(this.markerElement);
  }
  get anchor() {
    return __privateGet(this, _anchor);
  }
  set anchor(newAnchor) {
    __privateSet(this, _anchor, newAnchor);
    [this.anchorOffsetX, this.anchorOffsetY] = getAnchorOffset(this.markerElement, newAnchor);
    this.markerTransform = {
      anchorX: this.anchorOffsetX,
      anchorY: this.anchorOffsetY
    };
  }
  get markerTransform() {
    return __privateGet(this, _markerTransform);
  }
  set markerTransform(val) {
    __privateSet(this, _markerTransform, __spreadValues(__spreadValues({}, __privateGet(this, _markerTransform)), val));
    __privateGet(this, _updateMarkerTransform).call(this);
  }
  get isActive() {
    return __privateGet(this, _isActive);
  }
  set isActive(val) {
    this.imgContainerElement.style.touchAction = val ? "none" : "";
    __privateSet(this, _isActive, val);
  }
  get coordinate() {
    const adjustedPx = this.keepMarkerCentered ? this.imgCenterAdjustedPx : [
      this.imgCenterPx[0] - this.markerDeltaX,
      this.imgCenterPx[1] + this.markerDeltaY
    ];
    if (deepEquals(adjustedPx, this.imgCenterPx)) {
      return __privateGet(this, _originalCoordinate);
    } else {
      const lngLat = merc.ll(adjustedPx, this.zoom);
      return [round(lngLat[0], 6), round(lngLat[1], 6)];
    }
  }
  set coordinate(lngLat) {
    __privateSet(this, _originalCoordinate, lngLat);
    this.imgCenterPx = this.imgCenterAdjustedPx = merc.px(lngLat, this.zoom);
  }
  get imgCenterOffset() {
    return {
      x: this.imgCenterPx[0] - this.imgCenterAdjustedPx[0],
      y: this.imgCenterPx[1] - this.imgCenterAdjustedPx[1]
    };
  }
};
_anchor = new WeakMap();
_handleAnchorResize = new WeakMap();
_markerTransform = new WeakMap();
_isActive = new WeakMap();
_originalCoordinate = new WeakMap();
_onPointerDownMarker = new WeakMap();
_onPointerUpMarker = new WeakMap();
_onPointerMoveMarker = new WeakMap();
_onPointerDownImage = new WeakMap();
_onPointerUpImage = new WeakMap();
_onPointerMoveImage = new WeakMap();
_updatePointerPosition = new WeakMap();
_updateMarkerTransform = new WeakMap();
_updateMarkerCorrection = new WeakMap();

// src/icons/mapboxgl-ctrl-logo.svg
var mapboxgl_ctrl_logo_default = '<svg width="88" height="23" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill-rule="evenodd"><defs><path id="g" d="M11.5 2.25a9.25 9.25 0 1 1 0 18.5 9.25 9.25 0 0 1 0-18.5zM7 15.98c-.05-.33-.83-5.8 2.23-8.87a4.4 4.4 0 0 1 3.13-1.28c1.27 0 2.49.51 3.39 1.42.91.9 1.42 2.12 1.42 3.39a4.4 4.4 0 0 1-1.28 3.13C12.72 16.93 7 16 7 16v-.02zm8.3-5.48-2 .8-.8 2-.8-2-2-.8 2-.8.8-2 .8 2 2 .8z"/><path id="b" d="M50.63 8c.13 0 .23.1.23.23V9c.7-.76 1.7-1.18 2.73-1.18 2.17 0 3.95 1.85 3.95 4.17s-1.77 4.19-3.94 4.19A3.77 3.77 0 0 1 50.86 15v3.77c0 .13-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V8.23c0-.12.1-.23.23-.23h1.4zm-3.86.01.01-.01c.13 0 .22.1.22.22v7.55c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V15a3.7 3.7 0 0 1-2.73 1.19c-2.17 0-3.94-1.87-3.94-4.19 0-2.32 1.77-4.19 3.94-4.19 1.03 0 2.02.43 2.73 1.18v-.75c0-.12.1-.23.23-.23h1.4zm26.38-.19a4.24 4.24 0 0 0-4.16 3.29 4.07 4.07 0 0 0 0 1.77 4.23 4.23 0 0 0 4.17 3.3 4.22 4.22 0 0 0 4.26-4.19 4.2 4.2 0 0 0-4.27-4.17zM60.63 5c.13 0 .23.1.23.23v3.76c.7-.76 1.7-1.18 2.73-1.18a4 4 0 0 1 3.84 3.28c.13.59.13 1.2 0 1.8a4 4 0 0 1-3.84 3.29A3.77 3.77 0 0 1 60.86 15v.77c0 .12-.1.23-.23.23h-1.4a.23.23 0 0 1-.23-.23V5.23c0-.12.1-.23.23-.23h1.4zm-34 11h-1.4a.23.23 0 0 1-.23-.23V8.22c.01-.13.1-.22.23-.22h1.4c.13 0 .22.11.23.22v.68c.5-.68 1.3-1.09 2.16-1.1h.03c1.09 0 2.09.6 2.6 1.55a2.73 2.73 0 0 1 2.44-1.56c1.62 0 2.93 1.25 2.9 2.78l.03 5.2c0 .13-.1.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.8 0-1.46.7-1.59 1.62l.01 4.68c0 .13-.11.23-.23.23h-1.41a.23.23 0 0 1-.23-.23v-4.59c0-.98-.74-1.71-1.62-1.71-.85 0-1.54.79-1.6 1.8v4.5c0 .13-.1.23-.23.23zm53.62 0h-1.61a.27.27 0 0 1-.12-.03c-.1-.06-.13-.19-.06-.28l2.43-3.71-2.4-3.65a.21.21 0 0 1-.02-.12.2.2 0 0 1 .2-.21h1.61c.13 0 .24.06.3.17L82 10.54l1.4-2.37a.34.34 0 0 1 .3-.17h1.6l.12.03c.1.06.13.19.06.28l-2.37 3.65 2.43 3.7.01.13a.2.2 0 0 1-.2.21h-1.61a.33.33 0 0 1-.3-.17l-1.44-2.42-1.44 2.42a.34.34 0 0 1-.3.17zm-7.12-1.49A2.47 2.47 0 0 1 70.7 12a2.47 2.47 0 0 1 2.42-2.52 2.47 2.47 0 0 1 2.42 2.51 2.48 2.48 0 0 1-2.42 2.52zm-19.87 0a2.48 2.48 0 0 1-2.42-2.48v-.07a2.47 2.47 0 0 1 2.4-2.49 2.47 2.47 0 0 1 2.41 2.51 2.47 2.47 0 0 1-2.39 2.53zm-8.11-2.48c-.01 1.37-1.09 2.47-2.41 2.47s-2.42-1.12-2.42-2.51a2.47 2.47 0 0 1 2.4-2.52 2.46 2.46 0 0 1 2.41 2.48l.02.08zm18.12 2.47a2.47 2.47 0 0 1-2.41-2.48v-.06c.02-1.38 1.09-2.48 2.41-2.48s2.42 1.12 2.42 2.51a2.47 2.47 0 0 1-2.42 2.51z"/></defs><mask id="c"><rect width="100%" height="100%" fill="#fff"/><use xlink:href="#g"/><use xlink:href="#b"/></mask><g opacity=".3" stroke="#000" stroke-width="3"><circle mask="url(#c)" cx="11.5" cy="11.5" r="9.25"/><use xlink:href="#b" mask="url(#c)"/></g><g opacity=".9" fill="#fff"><use xlink:href="#g"/><use xlink:href="#b"/></g></svg>';

// src/components/MapboxAddressMinimap.ts
var ZOOM = 16;
var TEMPLATE4 = createElementFromString(`
<template>
  <div class="MapboxAddressMinimap" aria-hidden="true">
    <div class="MinimapImageContainer">
      <img class="MinimapImage" draggable="false"></img>
      <div class="MinimapInnerFrame">
        <div class="MinimapMarker"></div>
        <div class="MinimapAttribution">
          <div class="MinimapAttributionLogo">
            <a target="_blank" rel="noopener nofollow" href="https://www.mapbox.com/" aria-label="Mapbox logo">
              ${mapboxgl_ctrl_logo_default}
            </a>
          </div>
          <div class="MinimapAttributionText">
            <a target="_blank" href='https://www.mapbox.com/about/maps/'>\xA9 Mapbox</a><a target="_blank" href='http://www.openstreetmap.org/copyright'>\xA9 OpenStreetMap</a>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
`);
var STYLE_TOGGLE_TEMPLATE = createElementFromString(`
<template>
  <button type="button" class="MinimapStyleToggle"></button>
</template>
`);
var FOOTER_TEMPLATE = createElementFromString(`
<template>
  <div class="MinimapFooter">Adjust the marker on the map if it doesn't precisely match your location. This helps improve address data quality.</div>
</template>
`);
var ADJUST_PIN_TEXT = "Adjust pin";
var SAVE_TEXT = "Save";
var CANCEL_TEXT = "Cancel";
var EDIT_BUTTONS_TEMPLATE = createElementFromString(`
<template>
  <div class="MinimapEditButtons">
    <div class="Button ButtonPrimary MinimapButtonAdjust">${ADJUST_PIN_TEXT}</div>
    <div class="Button ButtonPrimary MinimapButtonSave" aria-hidden="true">${SAVE_TEXT}</div>
    <div class="Button MinimapButtonCancel" aria-hidden="true">${CANCEL_TEXT}</div>
  </div>
</template>
`);
var _canAdjustMarkerInternal, _isAdjustMarkerEditing, _imageLoaded, _feature2, _url, _width, _height, _binding6, _markerController, _accessToken, _themeInternal5, _satelliteToggleInternal, _mapStyleMode, _adjustBtnText, _saveBtnText, _cancelBtnText, _defaultMapStyle, _footer, _container, _toggleMarkerEditing, _handleStartMarkerEditing, _handleSaveMarkerEditing, _handleCancelMarkerEditing, _handleToggleMapStyle, _handleImageLoad, _handleImageError, _getImageUrl, _updateImageSrc, _getToggleBackgroundImageUrl, _setSize, _addMarkerEditControls, _removeMarkerEditControls, _addSatelliteToggle, _removeSatelliteToggle;
var MapboxAddressMinimap = class extends HTMLScopedElement {
  constructor() {
    super(...arguments);
    __privateAdd(this, _canAdjustMarkerInternal, false);
    this.keepMarkerCentered = false;
    this.markerAnchor = "bottom";
    __privateAdd(this, _isAdjustMarkerEditing, false);
    __privateAdd(this, _imageLoaded, false);
    __privateAdd(this, _feature2, void 0);
    __privateAdd(this, _url, "");
    __privateAdd(this, _width, void 0);
    __privateAdd(this, _height, void 0);
    __privateAdd(this, _binding6, void 0);
    __privateAdd(this, _markerController, void 0);
    __privateAdd(this, _accessToken, void 0);
    __privateAdd(this, _themeInternal5, {});
    __privateAdd(this, _satelliteToggleInternal, false);
    __privateAdd(this, _mapStyleMode, "default");
    __privateAdd(this, _adjustBtnText, void 0);
    __privateAdd(this, _saveBtnText, void 0);
    __privateAdd(this, _cancelBtnText, void 0);
    __privateAdd(this, _defaultMapStyle, ["mapbox", "streets-v11"]);
    __privateAdd(this, _footer, void 0);
    __privateAdd(this, _container, void 0);
    __privateAdd(this, _toggleMarkerEditing, () => {
      const { ImageContainer, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);
      if (__privateGet(this, _isAdjustMarkerEditing)) {
        ImageContainer.classList.add(`${this.dataset.seed}--draggable`);
        __privateGet(this, _markerController).isActive = true;
        ButtonAdjust.setAttribute("aria-hidden", "true");
        ButtonSave.removeAttribute("aria-hidden");
        ButtonCancel.removeAttribute("aria-hidden");
      } else {
        ImageContainer.classList.remove(`${this.dataset.seed}--draggable`);
        __privateGet(this, _markerController).isActive = false;
        ButtonAdjust.removeAttribute("aria-hidden");
        ButtonSave.setAttribute("aria-hidden", "true");
        ButtonCancel.setAttribute("aria-hidden", "true");
      }
    });
    __privateAdd(this, _handleStartMarkerEditing, () => {
      __privateSet(this, _isAdjustMarkerEditing, true);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleSaveMarkerEditing, () => {
      if (this.feature.properties.full_address && !deepEquals(this.feature.geometry.coordinates, __privateGet(this, _markerController).coordinate)) {
        const [lng, lat] = __privateGet(this, _markerController).coordinate;
        sendFeedback(this.accessToken, {
          originalCoordinate: this.feature.geometry.coordinates,
          originalAddress: this.feature.properties.full_address,
          changes: {
            location: { longitude: lng, latitude: lat }
          }
        });
      }
      if (this.onSaveMarkerLocation) {
        this.onSaveMarkerLocation(__privateGet(this, _markerController).coordinate);
      }
      __privateSet(this, _isAdjustMarkerEditing, false);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleCancelMarkerEditing, () => {
      __privateGet(this, _markerController).reCenter();
      __privateSet(this, _isAdjustMarkerEditing, false);
      __privateGet(this, _toggleMarkerEditing).call(this);
    });
    __privateAdd(this, _handleToggleMapStyle, () => {
      this.mapStyleMode = this.mapStyleMode === "default" ? "satellite" : "default";
    });
    __privateAdd(this, _handleImageLoad, () => {
      if (!__privateGet(this, _imageLoaded)) {
        __privateGet(this, _markerController).reCenter();
      }
      __privateSet(this, _imageLoaded, true);
      __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();
    });
    __privateAdd(this, _handleImageError, () => {
      __privateSet(this, _imageLoaded, false);
    });
    __privateAdd(this, _getImageUrl, (lngLatLike) => {
      if (__privateGet(this, _width) === 0 || __privateGet(this, _height) === 0)
        return "";
      const [username, styleId] = this.defaultMapStyle;
      const defaultBaseUrl = getStaticBaseUrl(username, styleId);
      const baseUrl = this.mapStyleMode === "default" ? defaultBaseUrl : STATIC_BASE_URL_SATELLITE;
      const skuToken = AUTOFILL_SKU_TOKEN_PREFIX + config.autofillSessionToken.toString();
      let imgUrl = baseUrl + import_search_js_core9.LngLat.convert(lngLatLike).toArray().join(",") + "," + ZOOM + ",0/" + Math.min(__privateGet(this, _width) * 2, MAX_IMAGE_DIM) + "x" + Math.min(__privateGet(this, _height) * 2, MAX_IMAGE_DIM) + "?access_token=" + this.accessToken + "&attribution=false&logo=false";
      if (config.autofillSessionEnabled) {
        imgUrl += `&sku=${skuToken}`;
      }
      return imgUrl;
    });
    __privateAdd(this, _updateImageSrc, () => {
      if (__privateGet(this, _feature2)) {
        const lngLat = __privateGet(this, _feature2).geometry.coordinates;
        __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));
        const { Image } = __privateGet(this, _binding6);
        Image.src = __privateGet(this, _url);
      }
    });
    __privateAdd(this, _getToggleBackgroundImageUrl, (styleMode) => {
      return `url("${getImage(styleMode === "default" ? "styleToggleDefault" : "styleToggleSatellite", this.theme)}")`;
    });
    __privateAdd(this, _setSize, () => {
      const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image } = __privateGet(this, _binding6);
      const { width, height } = getElementSize(this.container);
      const [oldWidth, oldHeight] = [__privateGet(this, _width), __privateGet(this, _height)];
      __privateSet(this, _width, Math.min(width, MAX_IMAGE_DIM));
      __privateSet(this, _height, Math.min(height, MAX_IMAGE_DIM));
      MapboxAddressMinimap2.style.setProperty("width", `${__privateGet(this, _width)}px`);
      MapboxAddressMinimap2.style.setProperty("height", `${__privateGet(this, _height)}px`);
      ImageContainer.style.setProperty("height", `${__privateGet(this, _height)}px`);
      ImageContainer.style.setProperty("width", `${__privateGet(this, _width)}px`);
      const [imgWidth, imgHeight] = [Image.width, Image.height];
      if (__privateGet(this, _width) > oldWidth && __privateGet(this, _width) > imgWidth / 2 && imgWidth < MAX_IMAGE_DIM || __privateGet(this, _height) > oldHeight && __privateGet(this, _height) > imgHeight / 2 && imgHeight < MAX_IMAGE_DIM) {
        __privateGet(this, _updateImageSrc).call(this);
      } else {
        __privateGet(this, _markerController) && __privateGet(this, _markerController).handleMinimapResize();
      }
    });
    __privateAdd(this, _addMarkerEditControls, () => {
      const existingFooter = this.querySelector(".MinimapFooter");
      if (existingFooter)
        return;
      const footerElement = this.prepareTemplate(FOOTER_TEMPLATE);
      const minimapElement = this.querySelector(".MapboxAddressMinimap");
      if (!minimapElement)
        return;
      minimapElement.appendChild(footerElement);
      const existingEditBtns = this.querySelector(".MinimapEditButtons");
      if (existingEditBtns)
        return;
      const editButtonsElement = this.prepareTemplate(EDIT_BUTTONS_TEMPLATE);
      const innerFrame = this.querySelector(".MinimapInnerFrame");
      innerFrame.appendChild(editButtonsElement);
      __privateSet(this, _binding6, __spreadProps(__spreadValues({}, __privateGet(this, _binding6)), {
        EditButtons: this.querySelector(".MinimapEditButtons"),
        ButtonAdjust: this.querySelector(".MinimapButtonAdjust"),
        ButtonSave: this.querySelector(".MinimapButtonSave"),
        ButtonCancel: this.querySelector(".MinimapButtonCancel")
      }));
      const { ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);
      ButtonAdjust.addEventListener("click", __privateGet(this, _handleStartMarkerEditing));
      ButtonSave.addEventListener("click", __privateGet(this, _handleSaveMarkerEditing));
      ButtonCancel.addEventListener("click", __privateGet(this, _handleCancelMarkerEditing));
    });
    __privateAdd(this, _removeMarkerEditControls, () => {
      if (!__privateGet(this, _binding6))
        return;
      const { EditButtons, ButtonAdjust, ButtonSave, ButtonCancel } = __privateGet(this, _binding6);
      const existingFooter = this.querySelector(".MinimapFooter");
      existingFooter == null ? void 0 : existingFooter.remove();
      EditButtons == null ? void 0 : EditButtons.remove();
      if (ButtonAdjust) {
        ButtonAdjust.remove();
        ButtonAdjust.removeEventListener("click", __privateGet(this, _handleStartMarkerEditing));
      }
      if (ButtonSave) {
        ButtonSave.remove();
        ButtonSave.removeEventListener("click", __privateGet(this, _handleSaveMarkerEditing));
      }
      if (ButtonCancel) {
        ButtonCancel.remove();
        ButtonCancel.removeEventListener("click", __privateGet(this, _handleCancelMarkerEditing));
      }
      delete __privateGet(this, _binding6).EditButtons;
      delete __privateGet(this, _binding6).ButtonAdjust;
      delete __privateGet(this, _binding6).ButtonSave;
      delete __privateGet(this, _binding6).ButtonCancel;
    });
    __privateAdd(this, _addSatelliteToggle, () => {
      const existingToggle = this.querySelector(".MinimapStyleToggle");
      if (existingToggle)
        return;
      const toggleElement = this.prepareTemplate(STYLE_TOGGLE_TEMPLATE);
      const innerFrame = this.querySelector(".MinimapInnerFrame");
      if (!innerFrame)
        return;
      innerFrame.appendChild(toggleElement);
      __privateGet(this, _binding6).MapStyleToggle = toggleElement;
      toggleElement.addEventListener("click", __privateGet(this, _handleToggleMapStyle));
      toggleElement.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === "default" ? "satellite" : "default");
      toggleElement.setAttribute("title", `Switch to ${this.mapStyleMode === "default" ? "Satellite" : "Default"}`);
    });
    __privateAdd(this, _removeSatelliteToggle, () => {
      if (!__privateGet(this, _binding6))
        return;
      const { MapStyleToggle } = __privateGet(this, _binding6);
      if (!MapStyleToggle)
        return;
      MapStyleToggle.remove();
      MapStyleToggle.removeEventListener("click", __privateGet(this, _handleToggleMapStyle));
      delete __privateGet(this, _binding6).MapStyleToggle;
    });
  }
  get canAdjustMarker() {
    return __privateGet(this, _canAdjustMarkerInternal);
  }
  set canAdjustMarker(val) {
    __privateSet(this, _canAdjustMarkerInternal, val);
    val ? __privateGet(this, _addMarkerEditControls).call(this) : __privateGet(this, _removeMarkerEditControls).call(this);
  }
  get accessToken() {
    return __privateGet(this, _accessToken) || config.accessToken;
  }
  set accessToken(newToken) {
    __privateSet(this, _accessToken, newToken);
  }
  get feature() {
    return __privateGet(this, _feature2);
  }
  set feature(feature) {
    __privateSet(this, _feature2, feature);
    if (!feature) {
      this.hide();
    } else {
      this.show();
    }
  }
  get template() {
    return TEMPLATE4;
  }
  get templateStyle() {
    return style_default;
  }
  get templateUserStyle() {
    return getThemeCSS(".MapboxAddressMinimap", this.theme);
  }
  get satelliteToggle() {
    return __privateGet(this, _satelliteToggleInternal);
  }
  set satelliteToggle(val) {
    __privateSet(this, _satelliteToggleInternal, val);
    val ? __privateGet(this, _addSatelliteToggle).call(this) : __privateGet(this, _removeSatelliteToggle).call(this);
  }
  get theme() {
    return __privateGet(this, _themeInternal5);
  }
  set theme(theme) {
    __privateSet(this, _themeInternal5, theme);
    if (!__privateGet(this, _binding6) || !theme) {
      return;
    }
    this.updateTemplateUserStyle(getThemeCSS(".MapboxAddressMinimap", theme));
    const { Marker, MapStyleToggle } = __privateGet(this, _binding6);
    Marker.innerHTML = getIcon("marker", theme);
    if (MapStyleToggle) {
      MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, this.mapStyleMode === "default" ? "satellite" : "default");
    }
  }
  get adjustBtnText() {
    return __privateGet(this, _adjustBtnText) || ADJUST_PIN_TEXT;
  }
  set adjustBtnText(val) {
    __privateSet(this, _adjustBtnText, val);
    const adjustBtn = this.querySelector(".MinimapButtonAdjust");
    adjustBtn.textContent = val || ADJUST_PIN_TEXT;
  }
  get saveBtnText() {
    return __privateGet(this, _saveBtnText) || SAVE_TEXT;
  }
  set saveBtnText(val) {
    __privateSet(this, _saveBtnText, val);
    const saveBtn = this.querySelector(".MinimapButtonSave");
    saveBtn.textContent = val || SAVE_TEXT;
  }
  get cancelBtnText() {
    return __privateGet(this, _cancelBtnText) || CANCEL_TEXT;
  }
  set cancelBtnText(val) {
    __privateSet(this, _cancelBtnText, val);
    const cancelBtn = this.querySelector(".MinimapButtonCancel");
    cancelBtn.textContent = val || CANCEL_TEXT;
  }
  get mapStyleMode() {
    return __privateGet(this, _mapStyleMode);
  }
  set mapStyleMode(styleMode) {
    const prevStyleMode = __privateGet(this, _mapStyleMode);
    if (prevStyleMode === styleMode)
      return;
    __privateSet(this, _mapStyleMode, styleMode);
    if (!__privateGet(this, _binding6)) {
      return;
    }
    const { MapStyleToggle } = __privateGet(this, _binding6);
    if (!MapStyleToggle) {
      return;
    }
    MapStyleToggle.style.backgroundImage = __privateGet(this, _getToggleBackgroundImageUrl).call(this, prevStyleMode);
    MapStyleToggle.setAttribute("title", `Switch to ${prevStyleMode === "satellite" ? "Satellite" : "Default"}`);
    __privateGet(this, _updateImageSrc).call(this);
  }
  get defaultMapStyle() {
    return __privateGet(this, _defaultMapStyle);
  }
  set defaultMapStyle(style) {
    __privateSet(this, _defaultMapStyle, style);
    __privateGet(this, _updateImageSrc).call(this);
  }
  get footer() {
    return __privateGet(this, _footer);
  }
  set footer(val) {
    __privateSet(this, _footer, val);
    const footerEl = this.querySelector(".MinimapFooter");
    if (footerEl) {
      if (typeof val === "string") {
        footerEl.textContent = val;
        footerEl.removeAttribute("aria-hidden");
      } else if (!val) {
        footerEl.setAttribute("aria-hidden", "true");
      } else {
        footerEl.removeAttribute("aria-hidden");
      }
    }
  }
  get container() {
    return __privateGet(this, _container);
  }
  set container(newContainer) {
    if (newContainer) {
      newContainer.style.position = "relative";
      __privateSet(this, _container, newContainer);
    }
  }
  show() {
    if (!__privateGet(this, _feature2)) {
      return;
    }
    const lngLat = __privateGet(this, _feature2).geometry.coordinates;
    __privateGet(this, _markerController).coordinate = lngLat;
    __privateSet(this, _url, __privateGet(this, _getImageUrl).call(this, lngLat));
    const { MapboxAddressMinimap: MapboxAddressMinimap2, Image } = __privateGet(this, _binding6);
    Image.src = __privateGet(this, _url);
    MapboxAddressMinimap2.removeAttribute("aria-hidden");
  }
  hide() {
    const { MapboxAddressMinimap: MapboxAddressMinimap2 } = __privateGet(this, _binding6);
    MapboxAddressMinimap2.setAttribute("aria-hidden", "true");
  }
  connectedCallback() {
    super.connectedCallback();
    __privateSet(this, _binding6, bindElements(this, {
      MapboxAddressMinimap: ".MapboxAddressMinimap",
      ImageContainer: ".MinimapImageContainer",
      Image: ".MinimapImage",
      Marker: ".MinimapMarker",
      MapStyleToggle: ".MinimapStyleToggle",
      EditButtons: ".MinimapEditButtons",
      ButtonAdjust: ".MinimapButtonAdjust",
      ButtonSave: ".MinimapButtonSave",
      ButtonCancel: ".MinimapButtonCancel"
    }));
    this.mapStyleMode = __privateGet(this, _mapStyleMode);
    this.theme = __spreadValues({}, this.theme);
    if (this.canAdjustMarker) {
      __privateGet(this, _addMarkerEditControls).call(this);
    }
    if (this.satelliteToggle) {
      __privateGet(this, _addSatelliteToggle).call(this);
    }
    this.container = this.parentElement;
    const resizeObserver = new ResizeObserver(__privateGet(this, _setSize));
    resizeObserver.observe(this.container);
    __privateGet(this, _setSize).call(this);
    const { MapboxAddressMinimap: MapboxAddressMinimap2, ImageContainer, Image, Marker } = __privateGet(this, _binding6);
    __privateSet(this, _markerController, new MarkerController(ImageContainer, Image, Marker, this.keepMarkerCentered, ZOOM, this.markerAnchor));
    __privateGet(this, _markerController).reCenter();
    Image.onload = __privateGet(this, _handleImageLoad);
    Image.onerror = __privateGet(this, _handleImageError);
    Image.src = __privateGet(this, _url);
    if (__privateGet(this, _feature2))
      MapboxAddressMinimap2.removeAttribute("aria-hidden");
    else
      MapboxAddressMinimap2.setAttribute("aria-hidden", "true");
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "access-token") {
      this.accessToken = newValue;
    } else if (name === "can-adjust-marker") {
      this.canAdjustMarker = newValue === "true";
    } else if (name === "keep-marker-centered") {
      this.keepMarkerCentered = newValue === "true";
    } else if (name === "marker-anchor") {
      const newAnchor = newValue;
      this.markerAnchor = newAnchor;
      __privateGet(this, _markerController) && (__privateGet(this, _markerController).anchor = newAnchor);
    } else if (name === "satellite-toggle") {
      this.satelliteToggle = newValue === "true";
    }
  }
};
_canAdjustMarkerInternal = new WeakMap();
_isAdjustMarkerEditing = new WeakMap();
_imageLoaded = new WeakMap();
_feature2 = new WeakMap();
_url = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_binding6 = new WeakMap();
_markerController = new WeakMap();
_accessToken = new WeakMap();
_themeInternal5 = new WeakMap();
_satelliteToggleInternal = new WeakMap();
_mapStyleMode = new WeakMap();
_adjustBtnText = new WeakMap();
_saveBtnText = new WeakMap();
_cancelBtnText = new WeakMap();
_defaultMapStyle = new WeakMap();
_footer = new WeakMap();
_container = new WeakMap();
_toggleMarkerEditing = new WeakMap();
_handleStartMarkerEditing = new WeakMap();
_handleSaveMarkerEditing = new WeakMap();
_handleCancelMarkerEditing = new WeakMap();
_handleToggleMapStyle = new WeakMap();
_handleImageLoad = new WeakMap();
_handleImageError = new WeakMap();
_getImageUrl = new WeakMap();
_updateImageSrc = new WeakMap();
_getToggleBackgroundImageUrl = new WeakMap();
_setSize = new WeakMap();
_addMarkerEditControls = new WeakMap();
_removeMarkerEditControls = new WeakMap();
_addSatelliteToggle = new WeakMap();
_removeSatelliteToggle = new WeakMap();
MapboxAddressMinimap.observedAttributes = [
  "access-token",
  "can-adjust-marker",
  "keep-marker-centered",
  "marker-anchor",
  "satellite-toggle"
];
window.MapboxAddressMinimap = MapboxAddressMinimap;
if (!window.customElements.get("mapbox-address-minimap")) {
  customElements.define("mapbox-address-minimap", MapboxAddressMinimap);
}

// src/autofill.ts
var import_search_js_core10 = require("@mapbox/search-js-core");
var _input3, _collection, _session3, _initialAutocompleteValue2, _onHandleInput3, _onHandleSelect3, _onHandleBlur3, _onHandleFocus2, _handleSuggest3, _handleSuggestError3, _handleRetrieve3;
var AddressAutofillInstance = class {
  constructor(collection, input, autofillRef) {
    __privateAdd(this, _input3, void 0);
    __privateAdd(this, _collection, void 0);
    __privateAdd(this, _session3, void 0);
    this.options = {};
    this.retrieveFeature = null;
    this.listbox = new MapboxSearchListbox();
    __privateAdd(this, _initialAutocompleteValue2, void 0);
    __privateAdd(this, _onHandleInput3, (e) => {
      const value = e.detail;
      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && (value == null ? void 0 : value.length) <= 2;
      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);
      if ((value == null ? void 0 : value.length) <= 2) {
        this.listbox.handleSuggest(null);
        return;
      }
      __privateGet(this, _session3).suggest(value, this.options);
    });
    __privateAdd(this, _onHandleSelect3, (e) => {
      const suggestion = e.detail;
      if (e.detail.accuracy !== "street") {
        toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), true);
        __privateGet(this, _session3).retrieve(suggestion, this.options);
      } else {
        handleStreetSelection(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), suggestion);
      }
    });
    __privateAdd(this, _onHandleBlur3, () => {
      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), true);
      __privateGet(this, _session3).abort();
    });
    __privateAdd(this, _onHandleFocus2, () => {
      var _a;
      const enableBrowserAutocomplete = __privateGet(this, _collection).browserAutofillEnabled === true && ((_a = __privateGet(this, _input3).value) == null ? void 0 : _a.length) <= 2;
      toggleAutocompletion(__privateGet(this, _input3), __privateGet(this, _initialAutocompleteValue2), enableBrowserAutocomplete);
    });
    __privateAdd(this, _handleSuggest3, (result) => {
      const filteredSuggestions = (result == null ? void 0 : result.suggestions) ? distinctExactStreetResults(result.suggestions) : null;
      this.listbox.handleSuggest(filteredSuggestions);
      const event = new MapboxHTMLEvent("suggest", result);
      Object.defineProperty(event, "target", { value: __privateGet(this, _input3) });
      __privateGet(this, _collection).fire("suggest", event);
    });
    __privateAdd(this, _handleSuggestError3, (error) => {
      this.listbox.handleError();
      const event = new MapboxHTMLEvent("suggesterror", error);
      Object.defineProperty(event, "target", { value: __privateGet(this, _input3) });
      __privateGet(this, _collection).fire("suggesterror", event);
    });
    __privateAdd(this, _handleRetrieve3, (result) => {
      var _a;
      const event = new MapboxHTMLEvent("retrieve", result);
      Object.defineProperty(event, "target", { value: __privateGet(this, _input3) });
      __privateGet(this, _collection).fire("retrieve", event);
      this.retrieveFeature = (_a = result.features) == null ? void 0 : _a[0];
      if (!__privateGet(this, _input3)) {
        return;
      }
      const featureCollection = result;
      if (!featureCollection || !featureCollection.features || !featureCollection.features.length) {
        return;
      }
      fillFormWithFeature(featureCollection.features[0], __privateGet(this, _input3));
    });
    __privateSet(this, _input3, input);
    __privateSet(this, _collection, collection);
    __privateSet(this, _session3, new import_search_js_core10.SearchSession(autofillRef));
    __privateGet(this, _session3).sessionToken = config.autofillSessionToken;
    this.listbox.input = __privateGet(this, _input3);
    this.listbox.autofillHost = this;
    this.listbox.searchService = 0 /* AddressAutofill */;
    this.listbox.addEventListener("input", __privateGet(this, _onHandleInput3));
    this.listbox.addEventListener("select", __privateGet(this, _onHandleSelect3));
    this.listbox.addEventListener("blur", __privateGet(this, _onHandleBlur3));
    this.listbox.addEventListener("focus", __privateGet(this, _onHandleFocus2));
    __privateGet(this, _session3).addEventListener("suggest", __privateGet(this, _handleSuggest3));
    __privateGet(this, _session3).addEventListener("suggesterror", __privateGet(this, _handleSuggestError3));
    __privateGet(this, _session3).addEventListener("retrieve", __privateGet(this, _handleRetrieve3));
    document.body.appendChild(this.listbox);
    if (input) {
      input.insertAdjacentElement("beforebegin", createAriaLiveElement(this.listbox.dataSeed));
      suppressExtensionsAutocomplete(input);
      __privateSet(this, _initialAutocompleteValue2, input.autocomplete);
    }
  }
  get input() {
    return __privateGet(this, _input3);
  }
  remove() {
    this.listbox.remove();
    this.listbox.removeEventListener("input", __privateGet(this, _onHandleInput3));
    this.listbox.removeEventListener("select", __privateGet(this, _onHandleSelect3));
    this.listbox.removeEventListener("blur", __privateGet(this, _onHandleBlur3));
    this.listbox.removeEventListener("focus", __privateGet(this, _onHandleFocus2));
    __privateGet(this, _session3).removeEventListener("suggest", __privateGet(this, _handleSuggest3));
    __privateGet(this, _session3).removeEventListener("suggesterror", __privateGet(this, _handleSuggestError3));
    __privateGet(this, _session3).removeEventListener("retrieve", __privateGet(this, _handleRetrieve3));
  }
  simulateRetrieve(feature) {
    const input = __privateGet(this, _input3);
    if (input) {
      input.dataset["mapboxSuccess"] = "true";
    }
    this.listbox.hideResults();
    const simResult = {
      type: "FeatureCollection",
      features: [feature],
      url: ""
    };
    __privateGet(this, _handleRetrieve3).call(this, simResult);
  }
};
_input3 = new WeakMap();
_collection = new WeakMap();
_session3 = new WeakMap();
_initialAutocompleteValue2 = new WeakMap();
_onHandleInput3 = new WeakMap();
_onHandleSelect3 = new WeakMap();
_onHandleBlur3 = new WeakMap();
_onHandleFocus2 = new WeakMap();
_handleSuggest3 = new WeakMap();
_handleSuggestError3 = new WeakMap();
_handleRetrieve3 = new WeakMap();
var _currentInputs, _autofill2, _options2, _theme, _popoverOptions2, _handleObserve2, _observer2, _handleBrowserAutofill2;
var AddressAutofillCollection = class extends import_search_js_core10.Evented {
  constructor({
    accessToken,
    options,
    theme,
    popoverOptions,
    confirmOnBrowserAutofill,
    browserAutofillEnabled
  }) {
    super();
    this.instances = [];
    __privateAdd(this, _currentInputs, void 0);
    __privateAdd(this, _autofill2, new import_search_js_core10.AddressAutofillCore());
    __privateAdd(this, _options2, void 0);
    __privateAdd(this, _theme, void 0);
    __privateAdd(this, _popoverOptions2, void 0);
    this.confirmOnBrowserAutofill = false;
    this.browserAutofillEnabled = false;
    __privateAdd(this, _handleObserve2, () => {
      if (!deepEquals(findAddressInputs(), __privateGet(this, _currentInputs))) {
        this.update();
      }
    });
    __privateAdd(this, _observer2, new MutationObserver(__privateGet(this, _handleObserve2)));
    __privateAdd(this, _handleBrowserAutofill2, (e) => __async(this, null, function* () {
      this.instances.forEach((instance) => instance.listbox.blur());
      for (const instance of this.instances) {
        const input = instance.listbox.input;
        yield tryConfirmBrowserAutofill(input, e, this.confirmOnBrowserAutofill, this.accessToken);
      }
    }));
    initDetectBrowserAutofill();
    window.addEventListener("browserautofill", __privateGet(this, _handleBrowserAutofill2));
    config.autofillSessionEnabled = true;
    this.accessToken = accessToken || config.accessToken;
    options && (this.options = options);
    theme && (this.theme = theme);
    popoverOptions && (this.popoverOptions = popoverOptions);
    confirmOnBrowserAutofill && (this.confirmOnBrowserAutofill = confirmOnBrowserAutofill);
    browserAutofillEnabled && (this.browserAutofillEnabled = browserAutofillEnabled);
    this.update();
  }
  get accessToken() {
    return __privateGet(this, _autofill2).accessToken;
  }
  set accessToken(newToken) {
    __privateGet(this, _autofill2).accessToken = newToken;
  }
  get options() {
    return __privateGet(this, _options2);
  }
  set options(newOptions) {
    __privateSet(this, _options2, __spreadValues(__spreadValues({}, __privateGet(this, _options2)), newOptions));
    this.instances.forEach((instance) => {
      instance.options = __spreadValues(__spreadValues({}, instance.options), newOptions);
    });
  }
  get theme() {
    return __privateGet(this, _theme);
  }
  set theme(newTheme) {
    __privateSet(this, _theme, newTheme);
    this.instances.forEach((instance) => {
      instance.listbox.theme = newTheme;
    });
  }
  get popoverOptions() {
    return __privateGet(this, _popoverOptions2);
  }
  set popoverOptions(newOptions) {
    __privateSet(this, _popoverOptions2, newOptions);
    this.instances.forEach((instance) => {
      instance.listbox.popoverOptions = newOptions;
    });
  }
  update() {
    this.instances.forEach((instance) => {
      instance.remove();
    });
    __privateSet(this, _currentInputs, findAddressInputs());
    this.instances = [];
    __privateGet(this, _currentInputs).forEach((input) => {
      const autofillInstance = new AddressAutofillInstance(this, input, __privateGet(this, _autofill2));
      autofillInstance.options = this.options;
      autofillInstance.listbox.theme = this.theme;
      autofillInstance.listbox.popoverOptions = this.popoverOptions;
      this.instances.push(autofillInstance);
    });
  }
  observe() {
    __privateGet(this, _observer2).observe(document, {
      subtree: true,
      childList: true
    });
    __privateGet(this, _handleObserve2).call(this);
  }
  unobserve() {
    __privateGet(this, _observer2).disconnect();
  }
  remove() {
    this.instances.forEach((instance) => {
      instance.remove();
    });
    this.unobserve();
    window.removeEventListener("browserautofill", __privateGet(this, _handleBrowserAutofill2));
  }
};
_currentInputs = new WeakMap();
_autofill2 = new WeakMap();
_options2 = new WeakMap();
_theme = new WeakMap();
_popoverOptions2 = new WeakMap();
_handleObserve2 = new WeakMap();
_observer2 = new WeakMap();
_handleBrowserAutofill2 = new WeakMap();
function autofill(optionsArg) {
  return new AddressAutofillCollection(optionsArg);
}
module.exports = __toCommonJS(src_exports);
//# sourceMappingURL=index-development.js.map
